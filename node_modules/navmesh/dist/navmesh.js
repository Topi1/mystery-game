!function(t,i){"object"==typeof exports&&"object"==typeof module?module.exports=i():"function"==typeof define&&define.amd?define([],i):"object"==typeof exports?exports.NavMesh=i():t.NavMesh=i()}("undefined"!=typeof self?self:this,(function(){return(()=>{var t={774:(t,i)=>{var n,o,e,s;s=function(){function t(t){for(var i=t,n=[];i.parent;)n.unshift(i),i=i.parent;return n}var i={search:function(n,o,s,r){n.cleanDirty();var h=(r=r||{}).heuristic||i.heuristics.manhattan,l=r.closest||!1,a=new e((function(t){return t.f})),c=o;for(o.h=h(o,s),n.markDirty(o),a.push(o);a.size()>0;){var u=a.pop();if(u===s)return t(u);u.closed=!0;for(var d=n.neighbors(u),g=0,p=d.length;g<p;++g){var f=d[g];if(!f.closed&&!f.isWall()){var y=u.g+f.getCost(u),x=f.visited;(!x||y<f.g)&&(f.visited=!0,f.parent=u,f.h=f.h||h(f,s),f.g=y,f.f=f.g+f.h,n.markDirty(f),l&&(f.h<c.h||f.h===c.h&&f.g<c.g)&&(c=f),x?a.rescoreElement(f):a.push(f))}}}return l?t(c):[]},heuristics:{manhattan:function(t,i){return Math.abs(i.x-t.x)+Math.abs(i.y-t.y)},diagonal:function(t,i){var n=Math.sqrt(2),o=Math.abs(i.x-t.x),e=Math.abs(i.y-t.y);return 1*(o+e)+(n-2)*Math.min(o,e)}},cleanNode:function(t){t.f=0,t.g=0,t.h=0,t.visited=!1,t.closed=!1,t.parent=null}};function n(t,i){i=i||{},this.nodes=[],this.diagonal=!!i.diagonal,this.grid=[];for(var n=0;n<t.length;n++){this.grid[n]=[];for(var e=0,s=t[n];e<s.length;e++){var r=new o(n,e,s[e]);this.grid[n][e]=r,this.nodes.push(r)}}this.init()}function o(t,i,n){this.x=t,this.y=i,this.weight=n}function e(t){this.content=[],this.scoreFunction=t}return n.prototype.init=function(){this.dirtyNodes=[];for(var t=0;t<this.nodes.length;t++)i.cleanNode(this.nodes[t])},n.prototype.cleanDirty=function(){for(var t=0;t<this.dirtyNodes.length;t++)i.cleanNode(this.dirtyNodes[t]);this.dirtyNodes=[]},n.prototype.markDirty=function(t){this.dirtyNodes.push(t)},n.prototype.neighbors=function(t){var i=[],n=t.x,o=t.y,e=this.grid;return e[n-1]&&e[n-1][o]&&i.push(e[n-1][o]),e[n+1]&&e[n+1][o]&&i.push(e[n+1][o]),e[n]&&e[n][o-1]&&i.push(e[n][o-1]),e[n]&&e[n][o+1]&&i.push(e[n][o+1]),this.diagonal&&(e[n-1]&&e[n-1][o-1]&&i.push(e[n-1][o-1]),e[n+1]&&e[n+1][o-1]&&i.push(e[n+1][o-1]),e[n-1]&&e[n-1][o+1]&&i.push(e[n-1][o+1]),e[n+1]&&e[n+1][o+1]&&i.push(e[n+1][o+1])),i},n.prototype.toString=function(){for(var t=[],i=this.grid,n=0;n<i.length;n++){for(var o=[],e=i[n],s=0;s<e.length;s++)o.push(e[s].weight);t.push(o.join(" "))}return t.join("\n")},o.prototype.toString=function(){return"["+this.x+" "+this.y+"]"},o.prototype.getCost=function(t){return t&&t.x!=this.x&&t.y!=this.y?1.41421*this.weight:this.weight},o.prototype.isWall=function(){return 0===this.weight},e.prototype={push:function(t){this.content.push(t),this.sinkDown(this.content.length-1)},pop:function(){var t=this.content[0],i=this.content.pop();return this.content.length>0&&(this.content[0]=i,this.bubbleUp(0)),t},remove:function(t){var i=this.content.indexOf(t),n=this.content.pop();i!==this.content.length-1&&(this.content[i]=n,this.scoreFunction(n)<this.scoreFunction(t)?this.sinkDown(i):this.bubbleUp(i))},size:function(){return this.content.length},rescoreElement:function(t){this.sinkDown(this.content.indexOf(t))},sinkDown:function(t){for(var i=this.content[t];t>0;){var n=(t+1>>1)-1,o=this.content[n];if(!(this.scoreFunction(i)<this.scoreFunction(o)))break;this.content[n]=i,this.content[t]=o,t=n}},bubbleUp:function(t){for(var i=this.content.length,n=this.content[t],o=this.scoreFunction(n);;){var e,s=t+1<<1,r=s-1,h=null;if(r<i){var l=this.content[r];(e=this.scoreFunction(l))<o&&(h=r)}if(s<i){var a=this.content[s];this.scoreFunction(a)<(null===h?o:e)&&(h=s)}if(null===h)break;this.content[t]=this.content[h],this.content[h]=n,t=h}}},{astar:i,Graph:n}},"object"==typeof t.exports?t.exports=s():(o=[],void 0===(e="function"==typeof(n=s)?n.apply(void 0,o):n)||(t.exports=e))}},i={};function n(o){var e=i[o];if(void 0!==e)return e.exports;var s=i[o]={exports:{}};return t[o](s,s.exports,n),s.exports}n.n=t=>{var i=t&&t.__esModule?()=>t.default:()=>t;return n.d(i,{a:i}),i},n.d=(t,i)=>{for(var o in i)n.o(i,o)&&!n.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:i[o]})},n.o=(t,i)=>Object.prototype.hasOwnProperty.call(t,i),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var o={};return(()=>{"use strict";n.r(o),n.d(o,{NavMesh:()=>f,PointQueue:()=>x,RectangleHull:()=>b,buildPolysFromGridMap:()=>m,default:()=>w});var t=n(774),i=n.n(t);class e{x;y;constructor(t=0,i=0){this.x=t,this.y=i}equals(t){return this.x===t.x&&this.y===t.y}angle(t){return Math.atan2(t.y-this.y,t.x-this.x)}distance(t){const i=t.x-this.x,n=t.y-this.y;return Math.sqrt(i*i+n*n)}add(t){this.x+=t.x,this.y+=t.y}subtract(t){this.x-=t.x,this.y-=t.y}clone(){return new e(this.x,this.y)}}class s{id;polygon;edges;neighbors;portals;centroid;boundingRadius;weight=1;x=0;y=0;constructor(t,i){this.id=t,this.polygon=i,this.edges=i.edges,this.neighbors=[],this.portals=[],this.centroid=this.calculateCentroid(),this.boundingRadius=this.calculateRadius()}getPoints(){return this.polygon.points}contains(t){return this.polygon.contains(t.x,t.y)||this.isPointOnEdge(t)}calculateCentroid(){const t=new e(0,0),i=this.polygon.points.length;return this.polygon.points.forEach((i=>t.add(i))),t.x/=i,t.y/=i,t}calculateRadius(){let t=0;for(const i of this.polygon.points){const n=this.centroid.distance(i);n>t&&(t=n)}return t}isPointOnEdge({x:t,y:i}){for(const n of this.edges)if(n.pointOnSegment(t,i))return!0;return!1}destroy(){this.neighbors=[],this.portals=[]}toString(){return`NavPoly(id: ${this.id} at: ${this.centroid})`}isWall(){return 0===this.weight}centroidDistance(t){return this.centroid.distance(t.centroid)}getCost(t){return this.centroidDistance(t)}}function r(t,i){const n=i.start,o=i.end,s=function(t,i){const n=i.x-t.x,o=i.y-t.y;return n*n+o*o}(n,o);let r=((t.x-n.x)*(o.x-n.x)+(t.y-n.y)*(o.y-n.y))/s;var h;return(h=r)<0&&(h=0),h>1&&(h=1),r=h,new e(n.x+r*(o.x-n.x),n.y+r*(o.y-n.y))}function h(t,i,n){const o=i.x-t.x,e=i.y-t.y;return(n.x-t.x)*e-o*(n.y-t.y)}function l(t,i,n=1e-4){return Math.abs(t-i)<=n}function a(t,i){let n=t-i;const o=n+Math.PI,e=2*Math.PI;return n=o-Math.floor(o/e)*e,n-=Math.PI,n}function c(t,i,n=1e-4){const o=h(t.start,t.end,i.start),e=h(t.start,t.end,i.end);return!(!l(o,0,n)||!l(e,0,n))}function u(t){return Boolean(t)}class d{path;portals;constructor(){this.portals=[],this.path=[]}push(t,i){void 0===i&&(i=t),this.portals.push({left:t,right:i})}stringPull(){const t=this.portals,i=[];let n=0,o=0,e=0,s=t[0].left,r=t[0].left,l=t[0].right;i.push(s);for(var a=1;a<t.length;a++){const c=t[a].left,u=t[a].right;if(h(s,l,u)<=0){if(!(s.equals(l)||h(s,r,u)>0)){i.push(r),s=r,n=o,r=s,l=s,o=n,e=n,a=n;continue}l=u,e=a}if(h(s,r,c)>=0){if(!(s.equals(r)||h(s,l,c)<0)){i.push(l),s=l,n=e,r=s,l=s,o=n,e=n,a=n;continue}r=c,o=a}}return 0!==i.length&&i[i.length-1].equals(t[t.length-1].left)||i.push(t[t.length-1].left),this.path=i,i}}class g{start;end;left;right;top;bottom;constructor(t,i,n,o){this.start=new e(t,i),this.end=new e(n,o),this.left=Math.min(t,n),this.right=Math.max(t,n),this.top=Math.min(i,o),this.bottom=Math.max(i,o)}pointOnSegment(t,i){return t>=this.left&&t<=this.right&&i>=this.top&&i<=this.bottom&&this.pointOnLine(t,i)}pointOnLine(t,i){return(t-this.left)*(this.bottom-this.top)==(this.right-this.left)*(i-this.top)}}class p{edges;points;isClosed;constructor(t,i=!0){this.isClosed=i,this.points=t,this.edges=[];for(let i=1;i<t.length;i++){const n=t[i-1],o=t[i];this.edges.push(new g(n.x,n.y,o.x,o.y))}if(this.isClosed){const i=t[0],n=t[t.length-1];this.edges.push(new g(i.x,i.y,n.x,n.y))}}contains(t,i){let n=!1;for(let o=-1,e=this.points.length-1;++o<this.points.length;e=o){const s=this.points[o].x,r=this.points[o].y,h=this.points[e].x,l=this.points[e].y;(r<=i&&i<l||l<=i&&i<r)&&t<(h-s)*(i-r)/(l-r)+s&&(n=!n)}return n}}class f{meshShrinkAmount;navPolygons;graph;constructor(t,n=0){this.meshShrinkAmount=n;const o=t.map((t=>{const i=t.map((t=>new e(t.x,t.y)));return new p(i)}));this.navPolygons=o.map(((t,i)=>new s(i,t))),this.calculateNeighbors(),this.graph=new class{nodes;grid=[];constructor(t){this.nodes=t,this.init()}neighbors(t){return t.neighbors}navHeuristic(t,i){return t.centroidDistance(i)}destroy(){this.cleanDirty(),this.nodes=[]}init=i().Graph.prototype.init.bind(this);cleanDirty=i().Graph.prototype.cleanDirty.bind(this);markDirty=i().Graph.prototype.markDirty.bind(this);toString=i().Graph.prototype.toString.bind(this)}(this.navPolygons)}getPolygons(){return this.navPolygons}destroy(){this.graph.destroy();for(const t of this.navPolygons)t.destroy();this.navPolygons=[]}isPointInMesh(t){return this.navPolygons.some((i=>i.contains(t)))}findClosestMeshPoint(t,i=Number.POSITIVE_INFINITY){let n=i,o=null,e=null;for(const i of this.navPolygons){if(i.contains(t)){n=0,o=i,e=t;break}const s=i.boundingRadius;if(i.centroid.distance(t)-s<n){const s=this.projectPointToPolygon(t,i);s.distance<n&&(n=s.distance,o=i,e=s.point)}}return{distance:n,polygon:o,point:e}}findPath(t,n){let o,s,r=null,h=null,l=Number.MAX_VALUE,a=Number.MAX_VALUE;const c=new e(t.x,t.y),u=new e(n.x,n.y);for(const t of this.navPolygons)s=t.boundingRadius,o=t.centroid.distance(c),o<=l&&o<=s&&t.contains(c)&&(r=t,l=o),o=t.centroid.distance(u),o<=a&&o<=s&&t.contains(u)&&(h=t,a=o);if(!h&&this.meshShrinkAmount>0)for(const t of this.navPolygons)if(s=t.boundingRadius+this.meshShrinkAmount,o=t.centroid.distance(u),o<=s){const{distance:i}=this.projectPointToPolygon(u,t);i<=this.meshShrinkAmount&&i<a&&(h=t,a=i)}if(!h)return null;if(!r&&this.meshShrinkAmount>0)for(const t of this.navPolygons)if(s=t.boundingRadius+this.meshShrinkAmount,o=t.centroid.distance(c),o<=s){const{distance:i}=this.projectPointToPolygon(c,t);i<=this.meshShrinkAmount&&i<l&&(r=t,l=i)}if(!r)return null;if(r===h)return[c,u];const g=i().astar.search(this.graph,r,h,{heuristic:this.graph.navHeuristic});if(0===g.length)return null;g.unshift(r);const p=new d;p.push(c);for(let t=0;t<g.length-1;t++){const i=g[t],n=g[t+1];let o=null;for(let t=0;t<i.neighbors.length;t++)i.neighbors[t].id===n.id&&(o=i.portals[t]);if(!o)throw new Error("Path was supposed to be found, but portal is missing!");p.push(o.start,o.end)}p.push(u),p.stringPull();let f=null;const y=[];for(const t of p.path){const i=t.clone();f&&i.equals(f)||y.push(i),f=i}return y}calculateNeighbors(){for(let t=0;t<this.navPolygons.length;t++){const i=this.navPolygons[t];for(let n=t+1;n<this.navPolygons.length;n++){const t=this.navPolygons[n];if(!(i.centroid.distance(t.centroid)>i.boundingRadius+t.boundingRadius))for(const n of i.edges)for(const o of t.edges){if(!c(n,o))continue;const e=this.getSegmentOverlap(n,o);if(!e)continue;i.neighbors.push(t),t.neighbors.push(i);const[s,r]=e;let h=i.centroid.angle(n.start),l=i.centroid.angle(e[0]),u=i.centroid.angle(e[1]),d=a(h,l),p=a(h,u);d<p?i.portals.push(new g(s.x,s.y,r.x,r.y)):i.portals.push(new g(r.x,r.y,s.x,s.y)),h=t.centroid.angle(o.start),l=t.centroid.angle(e[0]),u=t.centroid.angle(e[1]),d=a(h,l),p=a(h,u),d<p?t.portals.push(new g(s.x,s.y,r.x,r.y)):t.portals.push(new g(r.x,r.y,s.x,s.y))}}}}getSegmentOverlap(t,i){const n=[{line:t,point:t.start},{line:t,point:t.end},{line:i,point:i.start},{line:i,point:i.end}];n.sort((function(t,i){return t.point.x<i.point.x?-1:t.point.x>i.point.x?1:t.point.y<i.point.y?-1:t.point.y>i.point.y?1:0}));const o=n[0].line===n[1].line,e=n[1].point.equals(n[2].point);return o||e?null:[n[1].point,n[2].point]}projectPointToPolygon(t,i){let n=null,o=Number.MAX_VALUE;for(const e of i.edges){const i=r(t,e),s=t.distance(i);(null===n||s<o)&&(o=s,n=i)}return{point:n,distance:o}}}class y{width;height;tileWidth;tileHeight;map;isWalkableTest;constructor(t,i,n,o){this.map=t,this.isWalkableTest=i,this.height=t.length,this.width=t[0].length,this.tileWidth=n,this.tileHeight=o}forEach(t){this.map.forEach(((i,n)=>{i.forEach(((i,o)=>{t(o,n,this.map[n][o])}))}))}isInGrid(t,i){return t>=0&&t<this.width&&i>=0&&i<this.height}isWalkable(t,i){return this.isInGrid(t,i)&&this.isWalkableTest(this.map[i][t],t,i)}isBlocked(t,i){return this.isInGrid(t,i)&&!this.isWalkableTest(this.map[i][t],t,i)}isBlockedAtWorld(t,i){return this.isBlocked(this.getGridX(t),this.getGridY(i))}getGridX(t){return Math.floor(t/this.tileWidth)}getGridY(t){return Math.floor(t/this.tileHeight)}getGridXY(t,i){return{x:this.getGridX(t),y:this.getGridY(i)}}getWorldX(t){return t*this.tileWidth}getWorldY(t){return t*this.tileHeight}getWorldXY(t,i){return{x:this.getWorldX(t),y:this.getWorldY(i)}}}class x{data=[];add(t){this.data.push(t)}shift(){return this.data.shift()}isEmpty(){return 0===this.data.length}containsPoint(t){return void 0!==this.data.find((i=>i.x===t.x&&i.y===t.y))}containsAllPoints(t){return t.every((t=>this.containsPoint(t)))}getIndexOfPoint(t){return this.data.findIndex((i=>i.x==t.x&&i.y==t.y))}removePoint(t){const i=this.getIndexOfPoint(t);-1!==i&&this.data.splice(i,1)}removePoints(t){t.forEach((t=>this.removePoint(t)))}}class b{x;y;width;height;constructor(t,i,n,o){this.x=t,this.y=i,this.width=n,this.height=o}setPosition(t,i){this.x=t,this.y=i}setSize(t,i){this.width=t,this.height=i}set(t,i,n,o){this.setPosition(t,i),this.setSize(n,o)}get left(){return this.x}set left(t){this.x=t}get top(){return this.y}set top(t){this.y=t}get right(){return this.x+this.width}set right(t){this.width=t-this.x}get bottom(){return this.y+this.height}set bottom(t){this.height=t-this.top}get center(){return{x:(this.x+this.right)/2,y:(this.y+this.bottom)/2}}doesOverlap(t){return!(this.right<t.x||this.x>t.right||this.y>t.bottom||this.bottom<t.y)}attemptMergeIn(t){const i=this.x===t.x&&this.width===t.width,n=this.y===t.y&&this.height===t.height;return i&&this.top===t.bottom?(this.height+=t.height,this.y=t.y,!0):i&&this.bottom===t.top?(this.bottom=t.bottom,!0):n&&this.left===t.right?(this.width+=t.width,this.x=t.x,!0):!(!n||this.right!==t.left||(this.right=t.right,0))}toPoints(){const{left:t,right:i,top:n,bottom:o}=this;return[{x:t,y:n},{x:i,y:n},{x:i,y:o},{x:t,y:o}]}}function m(t,i=1,n=1,o=u,e=0){const s=new y(t,o,i,n);if(e>=i||e>=n)throw new Error(`navmesh: Unsupported shrink amount ${e}. Must be less than tile width and height.`);let r=function(t){const i=new x,{tileWidth:n,tileHeight:o}=t,e=[];let s;t.forEach(((n,o)=>{t.isWalkable(n,o)&&i.add({x:n,y:o})}));const r=(t,n)=>{const o=((t,i)=>{const{top:n,left:o,right:e,bottom:s}=t;let r=[];if("top"===i)for(let t=o;t<=e-1;t++)r.push({x:t,y:n});else if("bottom"===i)for(let t=o;t<=e-1;t++)r.push({x:t,y:s});else if("left"===i)for(let t=n;t<=s-1;t++)r.push({x:o,y:t});else{if("right"!==i)throw new Error(`Invalid dir "${i}" for extend`);for(let t=n;t<=s-1;t++)r.push({x:e,y:t})}return r})(t,n),e=i.containsAllPoints(o);return e&&(((t,i)=>{if("top"===i)t.y-=1;else if("bottom"===i)t.bottom+=1;else if("left"===i)t.x-=1;else{if("right"!==i)throw new Error(`Invalid dir "${i}" for extend`);t.right+=1}})(t,n),i.removePoints(o)),e};for(;!i.isEmpty();){const t=i.shift();if(void 0===t)break;s=new b(t.x,t.y,1,1);let h=!0;for(;h;){const t=r(s,"top"),i=r(s,"right"),n=r(s,"left"),o=r(s,"bottom");h=t||o||n||i}s.setPosition(s.x*n,s.y*o),s.setSize(s.width*n,s.height*o),e.push(s)}return e}(s);return e>0&&(r=function(t,i,n){const{tileHeight:o,tileWidth:e}=i,s=[],r=[];t.forEach(((t,h)=>{const l=o,a=e,c=i.getGridX(t.x),u=i.getGridY(t.y),d=i.getGridY(t.bottom),g=i.getGridX(t.right),p=v(t,i,n,e,o);if(t.left>=t.right||t.top>=t.bottom)return;r.push(t);const f=[],y=[],x=(t,i,n,o)=>{const e=new b(t,i,n,o);n>o?y.push(e):f.push(e)};if(p.left){const o=t.left-n;let e=u,s=e-1;for(let t=u;t<d;t++)i.isBlocked(c-1,t)?(e<=s&&x(o,e*l,n,(s-e+1)*l),e=t+1):s=t;e<=s&&x(o,e*l,n,(s-e+1)*l)}if(p.right){const o=t.right;let e=u,s=e-1;for(let t=u;t<d;t++)i.isBlocked(g,t)?(e<=s&&x(o,e*l,n,(s-e+1)*l),e=t+1):s=t;e<=s&&x(o,e*l,n,(s-e+1)*l)}if(p.top){const o=t.top-n;let e=c,s=e-1;for(let t=c;t<g;t++)i.isBlocked(t,u-1)?(e<=s&&x(e*a,o,(s-e+1)*l,n),e=t+1):s=t;e<=s&&x(e*a,o,(s-e+1)*l,n)}if(p.bottom){const o=t.bottom;let e=c,s=e-1;for(let t=c;t<g;t++)i.isBlocked(t,d)?(e<=s&&x(e*a,o,(s-e+1)*l,n),e=t+1):s=t;e<=s&&x(e*a,o,(s-e+1)*l,n)}y.forEach((t=>{f.forEach((i=>{t.doesOverlap(i)&&(t.y>i.y?i.height-=n:i.top+=n)}))})),[...y,...f].forEach((t=>{v(t,i,n,e,o),t.left>=t.right||t.top>=t.bottom||s.push(t)}))}));for(let i=0;i<s.length;i++){let n=!1;for(const o of t)if(n=o.attemptMergeIn(s[i]),n)break;if(!n){for(let t=i+1;t<s.length&&(n=s[t].attemptMergeIn(s[i]),!n);t++);n||r.push(s[i])}}return r}(r,s,e)),r.map((t=>t.toPoints()))}function v(t,i,n,o,e){const s=n,r=o/2,h=e/2,{left:l,top:a,right:c,bottom:u}=t,d={left:!1,right:!1,top:!1,bottom:!1,topLeft:i.isBlockedAtWorld(l-s,a-s),topRight:i.isBlockedAtWorld(c+s,a-s),bottomLeft:i.isBlockedAtWorld(l-s,u+s),bottomRight:i.isBlockedAtWorld(c+s,u+s)};for(let t=a+h;t<u;t+=h)if(i.isBlockedAtWorld(l-s,t)){d.left=!0;break}for(let t=a+h;t<u;t+=h)if(i.isBlockedAtWorld(c+s,t)){d.right=!0;break}for(let t=l+r;t<c;t+=r)if(i.isBlockedAtWorld(t,a-n)){d.top=!0;break}for(let t=l+r;t<c;t+=r)if(i.isBlockedAtWorld(t,u+n)){d.bottom=!0;break}const g={left:d.left,right:d.right,top:d.top,bottom:d.bottom};return!d.topLeft||d.left||d.top||(t.width>t.height?g.left=!0:g.top=!0),!d.topRight||d.right||d.top||(t.width>t.height?g.right=!0:g.top=!0),!d.bottomLeft||d.bottom||d.left||(t.width>t.height?g.left=!0:g.bottom=!0),!d.bottomRight||d.bottom||d.right||(t.width>t.height?g.right=!0:g.bottom=!0),g.left&&(t.x+=n,t.width-=n),g.top&&(t.y+=n,t.height-=n),g.right&&(t.width-=n),g.bottom&&(t.height-=n),g}const w=f})(),o})()}));
//# sourceMappingURL=navmesh.js.map