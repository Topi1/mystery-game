{"version":3,"sources":["webpack://NavMesh/webpack/universalModuleDefinition","webpack://NavMesh/../node_modules/javascript-astar/astar.js","webpack://NavMesh/webpack/bootstrap","webpack://NavMesh/webpack/runtime/compat get default export","webpack://NavMesh/webpack/runtime/define property getters","webpack://NavMesh/webpack/runtime/hasOwnProperty shorthand","webpack://NavMesh/webpack/runtime/make namespace object","webpack://NavMesh/./math/vector-2.ts","webpack://NavMesh/./navpoly.ts","webpack://NavMesh/./utils.ts","webpack://NavMesh/./channel.ts","webpack://NavMesh/./math/line.ts","webpack://NavMesh/./math/polygon.ts","webpack://NavMesh/./navmesh.ts","webpack://NavMesh/./navgraph.ts","webpack://NavMesh/./map-parsers/grid-map.ts","webpack://NavMesh/./map-parsers/point-queue.ts","webpack://NavMesh/./map-parsers/rectangle-hull.ts","webpack://NavMesh/./map-parsers/build-polys-from-grid-map.ts","webpack://NavMesh/./index.ts"],"names":["root","factory","exports","module","define","amd","self","this","definition","pathTo","node","curr","path","parent","unshift","astar","search","graph","start","end","options","cleanDirty","heuristic","heuristics","manhattan","closest","openHeap","BinaryHeap","f","closestNode","h","markDirty","push","size","currentNode","pop","closed","neighbors","i","il","length","neighbor","isWall","gScore","g","getCost","beenVisited","visited","rescoreElement","pos0","pos1","Math","abs","x","y","diagonal","D2","sqrt","d1","d2","min","cleanNode","Graph","gridIn","nodes","grid","row","GridNode","init","weight","scoreFunction","content","prototype","dirtyNodes","ret","toString","graphString","rowDebug","join","fromNeighbor","element","sinkDown","result","bubbleUp","remove","indexOf","n","parentN","elemScore","child1Score","child2N","child1N","swap","child1","child2","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","getter","__esModule","d","a","key","o","Object","defineProperty","enumerable","get","obj","prop","hasOwnProperty","call","r","Symbol","toStringTag","value","Vector2","v","atan2","dx","dy","NavPoly","id","polygon","edges","portals","centroid","calculateCentroid","boundingRadius","calculateRadius","points","point","contains","isPointOnEdge","forEach","p","add","distance","edge","pointOnSegment","navPolygon","centroidDistance","projectPointToEdge","line","b","l2","distanceSquared","t","triarea2","c","ax","ay","almostEqual","value1","value2","errorMargin","angleDifference","PI","j","floor","areCollinear","line1","line2","area1","area2","isTruthy","input","Boolean","Channel","p1","p2","left","right","pts","apexIndex","leftIndex","rightIndex","portalApex","portalLeft","portalRight","equals","Line","x1","y1","x2","y2","max","top","bottom","pointOnLine","Polygon","isClosed","first","last","inside","ix","iy","jx","jy","NavMesh","meshPolygonPoints","meshShrinkAmount","newPolys","map","polyPoints","vectors","navPolygons","calculateNeighbors","navPolygon1","navPolygon2","destroy","poly","some","navPoly","maxAllowableDist","Number","POSITIVE_INFINITY","minDistance","closestPoly","pointOnClosestPoly","projectPointToPolygon","startPoint","endPoint","startPoly","endPoly","startDistance","MAX_VALUE","endDistance","startVector","endVector","astarPath","navHeuristic","channel","nextNavPolygon","portal","Error","stringPull","lastPoint","phaserPath","newPoint","clone","otherNavPoly","otherEdge","overlap","getSegmentOverlap","edgeStartAngle","angle","a1","a2","sort","noOverlap","singlePointOverlap","closestProjection","closestDistance","projectedPoint","GridMap","isWalkable","tileWidth","tileHeight","isWalkableTest","height","width","fn","col","isInGrid","worldX","worldY","isBlocked","getGridX","getGridY","gridX","gridY","getWorldX","getWorldY","PointQueue","data","shift","find","every","containsPoint","findIndex","index","getIndexOfPoint","splice","removePoint","RectangleHull","setPosition","setSize","val","otherHull","horizontalMatch","verticalMatch","buildPolysFromGridMap","shrinkAmount","gridMap","hulls","walkableQueue","currentHull","attemptExtension","hull","dir","neighborPoints","getExtensionPoints","canExtend","containsAllPoints","extendHullInDirection","removePoints","isEmpty","tile","needsExtensionCheck","extendedTop","extendedRight","extendedLeft","extendedBottom","buildInitialHulls","newHulls","finalHulls","hullIndex","th","tw","tLeft","tTop","tBottom","tRight","shrink","shrinkHull","newVerticalHulls","newHorizontalHulls","addHull","w","startY","endY","startX","endX","hh","vh","doesOverlap","wasMerged","mainHull","attemptMergeIn","shrinkHulls","toPoints","s","halfWidth","halfHeight","info","topLeft","isBlockedAtWorld","topRight","bottomLeft","bottomRight"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAiB,QAAID,IAErBD,EAAc,QAAIC,IARpB,CASoB,oBAATK,KAAuBA,KAAOC,MAAO,WAChD,M,yBCVA,UAMUC,IAWP,WAEH,SAASC,EAAOC,GAGd,IAFA,IAAIC,EAAOD,EACPE,EAAO,GACJD,EAAKE,QACVD,EAAKE,QAAQH,GACbA,EAAOA,EAAKE,OAEd,OAAOD,EAST,IAAIG,EAAQ,CAYVC,OAAQ,SAASC,EAAOC,EAAOC,EAAKC,GAClCH,EAAMI,aAEN,IAAIC,GADJF,EAAUA,GAAW,IACGE,WAAaP,EAAMQ,WAAWC,UAClDC,EAAUL,EAAQK,UAAW,EAE7BC,EAvBC,IAAIC,GAAW,SAASjB,GAC7B,OAAOA,EAAKkB,KAuBRC,EAAcX,EAOlB,IALAA,EAAMY,EAAIR,EAAUJ,EAAOC,GAC3BF,EAAMc,UAAUb,GAEhBQ,EAASM,KAAKd,GAEPQ,EAASO,OAAS,GAAG,CAG1B,IAAIC,EAAcR,EAASS,MAG3B,GAAID,IAAgBf,EAClB,OAAOV,EAAOyB,GAIhBA,EAAYE,QAAS,EAKrB,IAFA,IAAIC,EAAYpB,EAAMoB,UAAUH,GAEvBI,EAAI,EAAGC,EAAKF,EAAUG,OAAQF,EAAIC,IAAMD,EAAG,CAClD,IAAIG,EAAWJ,EAAUC,GAEzB,IAAIG,EAASL,SAAUK,EAASC,SAAhC,CAOA,IAAIC,EAAST,EAAYU,EAAIH,EAASI,QAAQX,GAC1CY,EAAcL,EAASM,UAEtBD,GAAeH,EAASF,EAASG,KAGpCH,EAASM,SAAU,EACnBN,EAAS5B,OAASqB,EAClBO,EAASX,EAAIW,EAASX,GAAKR,EAAUmB,EAAUtB,GAC/CsB,EAASG,EAAID,EACbF,EAASb,EAAIa,EAASG,EAAIH,EAASX,EACnCb,EAAMc,UAAUU,GACZhB,IAGEgB,EAASX,EAAID,EAAYC,GAAMW,EAASX,IAAMD,EAAYC,GAAKW,EAASG,EAAIf,EAAYe,KAC1Ff,EAAcY,GAIbK,EAKHpB,EAASsB,eAAeP,GAHxBf,EAASM,KAAKS,MAStB,OAAIhB,EACKhB,EAAOoB,GAIT,IAGTN,WAAY,CACVC,UAAW,SAASyB,EAAMC,GAGxB,OAFSC,KAAKC,IAAIF,EAAKG,EAAIJ,EAAKI,GACvBF,KAAKC,IAAIF,EAAKI,EAAIL,EAAKK,IAGlCC,SAAU,SAASN,EAAMC,GACvB,IACIM,EAAKL,KAAKM,KAAK,GACfC,EAAKP,KAAKC,IAAIF,EAAKG,EAAIJ,EAAKI,GAC5BM,EAAKR,KAAKC,IAAIF,EAAKI,EAAIL,EAAKK,GAChC,OAJQ,GAIKI,EAAKC,IAASH,EAAK,GAAWL,KAAKS,IAAIF,EAAIC,KAG5DE,UAAW,SAASnD,GAClBA,EAAKkB,EAAI,EACTlB,EAAKkC,EAAI,EACTlC,EAAKoB,EAAI,EACTpB,EAAKqC,SAAU,EACfrC,EAAK0B,QAAS,EACd1B,EAAKG,OAAS,OAUlB,SAASiD,EAAMC,EAAQ3C,GACrBA,EAAUA,GAAW,GACrBb,KAAKyD,MAAQ,GACbzD,KAAKgD,WAAanC,EAAQmC,SAC1BhD,KAAK0D,KAAO,GACZ,IAAK,IAAIZ,EAAI,EAAGA,EAAIU,EAAOvB,OAAQa,IAAK,CACtC9C,KAAK0D,KAAKZ,GAAK,GAEf,IAAK,IAAIC,EAAI,EAAGY,EAAMH,EAAOV,GAAIC,EAAIY,EAAI1B,OAAQc,IAAK,CACpD,IAAI5C,EAAO,IAAIyD,EAASd,EAAGC,EAAGY,EAAIZ,IAClC/C,KAAK0D,KAAKZ,GAAGC,GAAK5C,EAClBH,KAAKyD,MAAMhC,KAAKtB,IAGpBH,KAAK6D,OAsFP,SAASD,EAASd,EAAGC,EAAGe,GACtB9D,KAAK8C,EAAIA,EACT9C,KAAK+C,EAAIA,EACT/C,KAAK8D,OAASA,EAmBhB,SAAS1C,EAAW2C,GAClB/D,KAAKgE,QAAU,GACfhE,KAAK+D,cAAgBA,EAsHvB,OAjOAR,EAAMU,UAAUJ,KAAO,WACrB7D,KAAKkE,WAAa,GAClB,IAAK,IAAInC,EAAI,EAAGA,EAAI/B,KAAKyD,MAAMxB,OAAQF,IACrCvB,EAAM8C,UAAUtD,KAAKyD,MAAM1B,KAI/BwB,EAAMU,UAAUnD,WAAa,WAC3B,IAAK,IAAIiB,EAAI,EAAGA,EAAI/B,KAAKkE,WAAWjC,OAAQF,IAC1CvB,EAAM8C,UAAUtD,KAAKkE,WAAWnC,IAElC/B,KAAKkE,WAAa,IAGpBX,EAAMU,UAAUzC,UAAY,SAASrB,GACnCH,KAAKkE,WAAWzC,KAAKtB,IAGvBoD,EAAMU,UAAUnC,UAAY,SAAS3B,GACnC,IAAIgE,EAAM,GACNrB,EAAI3C,EAAK2C,EACTC,EAAI5C,EAAK4C,EACTW,EAAO1D,KAAK0D,KA4ChB,OAzCIA,EAAKZ,EAAI,IAAMY,EAAKZ,EAAI,GAAGC,IAC7BoB,EAAI1C,KAAKiC,EAAKZ,EAAI,GAAGC,IAInBW,EAAKZ,EAAI,IAAMY,EAAKZ,EAAI,GAAGC,IAC7BoB,EAAI1C,KAAKiC,EAAKZ,EAAI,GAAGC,IAInBW,EAAKZ,IAAMY,EAAKZ,GAAGC,EAAI,IACzBoB,EAAI1C,KAAKiC,EAAKZ,GAAGC,EAAI,IAInBW,EAAKZ,IAAMY,EAAKZ,GAAGC,EAAI,IACzBoB,EAAI1C,KAAKiC,EAAKZ,GAAGC,EAAI,IAGnB/C,KAAKgD,WAEHU,EAAKZ,EAAI,IAAMY,EAAKZ,EAAI,GAAGC,EAAI,IACjCoB,EAAI1C,KAAKiC,EAAKZ,EAAI,GAAGC,EAAI,IAIvBW,EAAKZ,EAAI,IAAMY,EAAKZ,EAAI,GAAGC,EAAI,IACjCoB,EAAI1C,KAAKiC,EAAKZ,EAAI,GAAGC,EAAI,IAIvBW,EAAKZ,EAAI,IAAMY,EAAKZ,EAAI,GAAGC,EAAI,IACjCoB,EAAI1C,KAAKiC,EAAKZ,EAAI,GAAGC,EAAI,IAIvBW,EAAKZ,EAAI,IAAMY,EAAKZ,EAAI,GAAGC,EAAI,IACjCoB,EAAI1C,KAAKiC,EAAKZ,EAAI,GAAGC,EAAI,KAItBoB,GAGTZ,EAAMU,UAAUG,SAAW,WAGzB,IAFA,IAAIC,EAAc,GACdZ,EAAQzD,KAAK0D,KACRZ,EAAI,EAAGA,EAAIW,EAAMxB,OAAQa,IAAK,CAGrC,IAFA,IAAIwB,EAAW,GACXX,EAAMF,EAAMX,GACPC,EAAI,EAAGA,EAAIY,EAAI1B,OAAQc,IAC9BuB,EAAS7C,KAAKkC,EAAIZ,GAAGe,QAEvBO,EAAY5C,KAAK6C,EAASC,KAAK,MAEjC,OAAOF,EAAYE,KAAK,OAS1BX,EAASK,UAAUG,SAAW,WAC5B,MAAO,IAAMpE,KAAK8C,EAAI,IAAM9C,KAAK+C,EAAI,KAGvCa,EAASK,UAAU3B,QAAU,SAASkC,GAEpC,OAAIA,GAAgBA,EAAa1B,GAAK9C,KAAK8C,GAAK0B,EAAazB,GAAK/C,KAAK+C,EAChD,QAAd/C,KAAK8D,OAEP9D,KAAK8D,QAGdF,EAASK,UAAU9B,OAAS,WAC1B,OAAuB,IAAhBnC,KAAK8D,QAQd1C,EAAW6C,UAAY,CACrBxC,KAAM,SAASgD,GAEbzE,KAAKgE,QAAQvC,KAAKgD,GAGlBzE,KAAK0E,SAAS1E,KAAKgE,QAAQ/B,OAAS,IAEtCL,IAAK,WAEH,IAAI+C,EAAS3E,KAAKgE,QAAQ,GAEtBpD,EAAMZ,KAAKgE,QAAQpC,MAOvB,OAJI5B,KAAKgE,QAAQ/B,OAAS,IACxBjC,KAAKgE,QAAQ,GAAKpD,EAClBZ,KAAK4E,SAAS,IAETD,GAETE,OAAQ,SAAS1E,GACf,IAAI4B,EAAI/B,KAAKgE,QAAQc,QAAQ3E,GAIzBS,EAAMZ,KAAKgE,QAAQpC,MAEnBG,IAAM/B,KAAKgE,QAAQ/B,OAAS,IAC9BjC,KAAKgE,QAAQjC,GAAKnB,EAEdZ,KAAK+D,cAAcnD,GAAOZ,KAAK+D,cAAc5D,GAC/CH,KAAK0E,SAAS3C,GAEd/B,KAAK4E,SAAS7C,KAIpBL,KAAM,WACJ,OAAO1B,KAAKgE,QAAQ/B,QAEtBQ,eAAgB,SAAStC,GACvBH,KAAK0E,SAAS1E,KAAKgE,QAAQc,QAAQ3E,KAErCuE,SAAU,SAASK,GAKjB,IAHA,IAAIN,EAAUzE,KAAKgE,QAAQe,GAGpBA,EAAI,GAAG,CAGZ,IAAIC,GAAYD,EAAI,GAAM,GAAK,EAC3BzE,EAASN,KAAKgE,QAAQgB,GAE1B,KAAIhF,KAAK+D,cAAcU,GAAWzE,KAAK+D,cAAczD,IAQnD,MAPAN,KAAKgE,QAAQgB,GAAWP,EACxBzE,KAAKgE,QAAQe,GAAKzE,EAElByE,EAAIC,IAQVJ,SAAU,SAASG,GAMjB,IAJA,IAAI9C,EAASjC,KAAKgE,QAAQ/B,OACtBwC,EAAUzE,KAAKgE,QAAQe,GACvBE,EAAYjF,KAAK+D,cAAcU,KAEtB,CAEX,IAIIS,EAJAC,EAAWJ,EAAI,GAAM,EACrBK,EAAUD,EAAU,EAEpBE,EAAO,KAGX,GAAID,EAAUnD,EAAQ,CAEpB,IAAIqD,EAAStF,KAAKgE,QAAQoB,IAC1BF,EAAclF,KAAK+D,cAAcuB,IAGfL,IAChBI,EAAOD,GAKX,GAAID,EAAUlD,EAAQ,CACpB,IAAIsD,EAASvF,KAAKgE,QAAQmB,GACRnF,KAAK+D,cAAcwB,IACT,OAATF,EAAgBJ,EAAYC,KAC7CG,EAAOF,GAKX,GAAa,OAATE,EAOF,MANArF,KAAKgE,QAAQe,GAAK/E,KAAKgE,QAAQqB,GAC/BrF,KAAKgE,QAAQqB,GAAQZ,EACrBM,EAAIM,KAUL,CACL7E,MAAOA,EACP+C,MAAOA,IAxYqD,iBAAnB3D,EAAOD,QAC9CC,EAAOD,QAAUM,KAEjB,EAAO,QAAc,0BAAV,EAAF,GAAY,aAChB,EADgB,wBCVrBuF,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAahG,QAGrB,IAAIC,EAAS4F,EAAyBE,GAAY,CAGjD/F,QAAS,IAOV,OAHAkG,EAAoBH,GAAU9F,EAAQA,EAAOD,QAAS8F,GAG/C7F,EAAOD,QCpBf8F,EAAoBV,EAAKnF,IACxB,IAAIkG,EAASlG,GAAUA,EAAOmG,WAC7B,IAAOnG,EAAiB,QACxB,IAAM,EAEP,OADA6F,EAAoBO,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,GCLRL,EAAoBO,EAAI,CAACrG,EAASM,KACjC,IAAI,IAAIiG,KAAOjG,EACXwF,EAAoBU,EAAElG,EAAYiG,KAAST,EAAoBU,EAAExG,EAASuG,IAC5EE,OAAOC,eAAe1G,EAASuG,EAAK,CAAEI,YAAY,EAAMC,IAAKtG,EAAWiG,MCJ3ET,EAAoBU,EAAI,CAACK,EAAKC,IAAUL,OAAOnC,UAAUyC,eAAeC,KAAKH,EAAKC,GCClFhB,EAAoBmB,EAAKjH,IACH,oBAAXkH,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAe1G,EAASkH,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAe1G,EAAS,aAAc,CAAEoH,OAAO,K,qKCCxC,MAAMC,EACjB,EACA,EACA,YAAYlE,EAAI,EAAGC,EAAI,GACnB/C,KAAK8C,EAAIA,EACT9C,KAAK+C,EAAIA,EAEb,OAAOkE,GACH,OAAOjH,KAAK8C,IAAMmE,EAAEnE,GAAK9C,KAAK+C,IAAMkE,EAAElE,EAE1C,MAAMkE,GACF,OAAOrE,KAAKsE,MAAMD,EAAElE,EAAI/C,KAAK+C,EAAGkE,EAAEnE,EAAI9C,KAAK8C,GAE/C,SAASmE,GACL,MAAME,EAAKF,EAAEnE,EAAI9C,KAAK8C,EAChBsE,EAAKH,EAAElE,EAAI/C,KAAK+C,EACtB,OAAOH,KAAKM,KAAKiE,EAAKA,EAAKC,EAAKA,GAEpC,IAAIH,GACAjH,KAAK8C,GAAKmE,EAAEnE,EACZ9C,KAAK+C,GAAKkE,EAAElE,EAEhB,SAASkE,GACLjH,KAAK8C,GAAKmE,EAAEnE,EACZ9C,KAAK+C,GAAKkE,EAAElE,EAEhB,QACI,OAAO,IAAIiE,EAAQhH,KAAK8C,EAAG9C,KAAK+C,IC1BzB,MAAMsE,EACjB,GACA,QACA,MACA,UACA,QACA,SACA,eAEA,OAAS,EACT,EAAI,EACJ,EAAI,EAIJ,YAAYC,EAAIC,GACZvH,KAAKsH,GAAKA,EACVtH,KAAKuH,QAAUA,EACfvH,KAAKwH,MAAQD,EAAQC,MACrBxH,KAAK8B,UAAY,GACjB9B,KAAKyH,QAAU,GACfzH,KAAK0H,SAAW1H,KAAK2H,oBACrB3H,KAAK4H,eAAiB5H,KAAK6H,kBAK/B,YACI,OAAO7H,KAAKuH,QAAQO,OAKxB,SAASC,GAGL,OAAO/H,KAAKuH,QAAQS,SAASD,EAAMjF,EAAGiF,EAAMhF,IAAM/C,KAAKiI,cAAcF,GAOzE,oBACI,MAAML,EAAW,IAAIV,EAAQ,EAAG,GAC1B/E,EAASjC,KAAKuH,QAAQO,OAAO7F,OAInC,OAHAjC,KAAKuH,QAAQO,OAAOI,SAASC,GAAMT,EAASU,IAAID,KAChDT,EAAS5E,GAAKb,EACdyF,EAAS3E,GAAKd,EACPyF,EAKX,kBACI,IAAIE,EAAiB,EACrB,IAAK,MAAMG,KAAS/H,KAAKuH,QAAQO,OAAQ,CACrC,MAAM9B,EAAIhG,KAAK0H,SAASW,SAASN,GAC7B/B,EAAI4B,IACJA,EAAiB5B,GAEzB,OAAO4B,EAKX,eAAc,EAAE9E,EAAC,EAAEC,IACf,IAAK,MAAMuF,KAAQtI,KAAKwH,MACpB,GAAIc,EAAKC,eAAezF,EAAGC,GACvB,OAAO,EAEf,OAAO,EAEX,UACI/C,KAAK8B,UAAY,GACjB9B,KAAKyH,QAAU,GAGnB,WACI,MAAO,eAAezH,KAAKsH,UAAUtH,KAAK0H,YAE9C,SACI,OAAuB,IAAhB1H,KAAK8D,OAEhB,iBAAiB0E,GACb,OAAOxI,KAAK0H,SAASW,SAASG,EAAWd,UAE7C,QAAQc,GACJ,OAAOxI,KAAKyI,iBAAiBD,IC7E9B,SAASE,EAAmBX,EAAOY,GACtC,MAAM1C,EAAI0C,EAAKhI,MACTiI,EAAID,EAAK/H,IAITiI,EAjBH,SAAyB5C,EAAG2C,GAC/B,MAAMzB,EAAKyB,EAAE9F,EAAImD,EAAEnD,EACbsE,EAAKwB,EAAE7F,EAAIkD,EAAElD,EACnB,OAAOoE,EAAKA,EAAKC,EAAKA,EAcX0B,CAAgB7C,EAAG2C,GAC9B,IAAIG,IAAMhB,EAAMjF,EAAImD,EAAEnD,IAAM8F,EAAE9F,EAAImD,EAAEnD,IAAMiF,EAAMhF,EAAIkD,EAAElD,IAAM6F,EAAE7F,EAAIkD,EAAElD,IAAM8F,EAoBvE,IAAe9B,EAflB,OAekBA,EAlBRgC,GAAG,IAoBThC,EApBS,GAqBTA,EArBY,IAsBZA,EAtBY,GAAhBgC,EAuBOhC,EArBG,IAAIC,EAAQf,EAAEnD,EAAIiG,GAAKH,EAAE9F,EAAImD,EAAEnD,GAAImD,EAAElD,EAAIgG,GAAKH,EAAE7F,EAAIkD,EAAElD,IAM7D,SAASiG,EAAS/C,EAAG2C,EAAGK,GAC3B,MAAMC,EAAKN,EAAE9F,EAAImD,EAAEnD,EACbqG,EAAKP,EAAE7F,EAAIkD,EAAElD,EAGnB,OAFWkG,EAAEnG,EAAImD,EAAEnD,GAEPqG,EAAKD,GADND,EAAElG,EAAIkD,EAAElD,GAgBhB,SAASqG,EAAYC,EAAQC,EAAQC,EAAc,MACtD,OAAI3G,KAAKC,IAAIwG,EAASC,IAAWC,EAS9B,SAASC,EAAgB1G,EAAGC,GAC/B,IAAIkD,EAAInD,EAAIC,EACZ,MAAMhB,EAAIkE,EAAIrD,KAAK6G,GACbC,EAAc,EAAV9G,KAAK6G,GAGf,OAFAxD,EAAIlE,EAAIa,KAAK+G,MAAM5H,EAAI2H,GAAKA,EAC5BzD,GAAKrD,KAAK6G,GACHxD,EAKJ,SAAS2D,EAAaC,EAAOC,EAAOP,EAAc,MAGrD,MAAMQ,EAAQf,EAASa,EAAMlJ,MAAOkJ,EAAMjJ,IAAKkJ,EAAMnJ,OAC/CqJ,EAAQhB,EAASa,EAAMlJ,MAAOkJ,EAAMjJ,IAAKkJ,EAAMlJ,KACrD,SAAIwI,EAAYW,EAAO,EAAGR,KAAgBH,EAAYY,EAAO,EAAGT,IAM7D,SAASU,EAASC,GACrB,OAAOC,QAAQD,GClFJ,MAAME,EACjB,KACA,QACA,cACIpK,KAAKyH,QAAU,GACfzH,KAAKK,KAAO,GAEhB,KAAKgK,EAAIC,QACM1E,IAAP0E,IACAA,EAAKD,GACTrK,KAAKyH,QAAQhG,KAAK,CACd8I,KAAMF,EACNG,MAAOF,IAGf,aACI,MAAM7C,EAAUzH,KAAKyH,QACfgD,EAAM,GAEZ,IAAIC,EAAY,EACZC,EAAY,EACZC,EAAa,EACbC,EAAapD,EAAQ,GAAG8C,KACxBO,EAAarD,EAAQ,GAAG8C,KACxBQ,EAActD,EAAQ,GAAG+C,MAE7BC,EAAIhJ,KAAKoJ,GACT,IAAK,IAAI9I,EAAI,EAAGA,EAAI0F,EAAQxF,OAAQF,IAAK,CAErC,MAAMwI,EAAO9C,EAAQ1F,GAAGwI,KAClBC,EAAQ/C,EAAQ1F,GAAGyI,MAEzB,GAAIxB,EAAS6B,EAAYE,EAAaP,IAAU,EAAK,CACjD,KAAIK,EAAWG,OAAOD,IAAgB/B,EAAS6B,EAAYC,EAAYN,GAAS,GAK3E,CAGDC,EAAIhJ,KAAKqJ,GAGTD,EAAaC,EACbJ,EAAYC,EAEZG,EAAaD,EACbE,EAAcF,EACdF,EAAYD,EACZE,EAAaF,EAEb3I,EAAI2I,EACJ,SAlBAK,EAAcP,EACdI,EAAa7I,EAqBrB,GAAIiH,EAAS6B,EAAYC,EAAYP,IAAS,EAAK,CAC/C,KAAIM,EAAWG,OAAOF,IAAe9B,EAAS6B,EAAYE,EAAaR,GAAQ,GAK1E,CAGDE,EAAIhJ,KAAKsJ,GAGTF,EAAaE,EACbL,EAAYE,EAEZE,EAAaD,EACbE,EAAcF,EACdF,EAAYD,EACZE,EAAaF,EAEb3I,EAAI2I,EACJ,SAlBAI,EAAaP,EACbI,EAAY5I,GA0BxB,OALmB,IAAf0I,EAAIxI,QAAiBwI,EAAIA,EAAIxI,OAAS,GAAG+I,OAAOvD,EAAQA,EAAQxF,OAAS,GAAGsI,OAE5EE,EAAIhJ,KAAKgG,EAAQA,EAAQxF,OAAS,GAAGsI,MAEzCvK,KAAKK,KAAOoK,EACLA,GCtFA,MAAMQ,EACjB,MACA,IACA,KACA,MACA,IACA,OACA,YAAYC,EAAIC,EAAIC,EAAIC,GACpBrL,KAAKW,MAAQ,IAAIqG,EAAQkE,EAAIC,GAC7BnL,KAAKY,IAAM,IAAIoG,EAAQoE,EAAIC,GAC3BrL,KAAKuK,KAAO3H,KAAKS,IAAI6H,EAAIE,GACzBpL,KAAKwK,MAAQ5H,KAAK0I,IAAIJ,EAAIE,GAC1BpL,KAAKuL,IAAM3I,KAAKS,IAAI8H,EAAIE,GACxBrL,KAAKwL,OAAS5I,KAAK0I,IAAIH,EAAIE,GAE/B,eAAevI,EAAGC,GACd,OAAQD,GAAK9C,KAAKuK,MACdzH,GAAK9C,KAAKwK,OACVzH,GAAK/C,KAAKuL,KACVxI,GAAK/C,KAAKwL,QACVxL,KAAKyL,YAAY3I,EAAGC,GAE5B,YAAYD,EAAGC,GAEX,OAAQD,EAAI9C,KAAKuK,OAASvK,KAAKwL,OAASxL,KAAKuL,OAAUvL,KAAKwK,MAAQxK,KAAKuK,OAASxH,EAAI/C,KAAKuL,MCxBpF,MAAMG,EACjB,MACA,OACA,SACA,YAAY5D,EAAQjG,GAAS,GACzB7B,KAAK2L,SAAW9J,EAChB7B,KAAK8H,OAASA,EACd9H,KAAKwH,MAAQ,GACb,IAAK,IAAIzF,EAAI,EAAGA,EAAI+F,EAAO7F,OAAQF,IAAK,CACpC,MAAMsI,EAAKvC,EAAO/F,EAAI,GAChBuI,EAAKxC,EAAO/F,GAClB/B,KAAKwH,MAAM/F,KAAK,IAAIwJ,EAAKZ,EAAGvH,EAAGuH,EAAGtH,EAAGuH,EAAGxH,EAAGwH,EAAGvH,IAElD,GAAI/C,KAAK2L,SAAU,CACf,MAAMC,EAAQ9D,EAAO,GACf+D,EAAO/D,EAAOA,EAAO7F,OAAS,GACpCjC,KAAKwH,MAAM/F,KAAK,IAAIwJ,EAAKW,EAAM9I,EAAG8I,EAAM7I,EAAG8I,EAAK/I,EAAG+I,EAAK9I,KAGhE,SAASD,EAAGC,GACR,IAAI+I,GAAS,EACb,IAAK,IAAI/J,GAAK,EAAG2H,EAAI1J,KAAK8H,OAAO7F,OAAS,IAAKF,EAAI/B,KAAK8H,OAAO7F,OAAQyH,EAAI3H,EAAG,CAC1E,MAAMgK,EAAK/L,KAAK8H,OAAO/F,GAAGe,EACpBkJ,EAAKhM,KAAK8H,OAAO/F,GAAGgB,EACpBkJ,EAAKjM,KAAK8H,OAAO4B,GAAG5G,EACpBoJ,EAAKlM,KAAK8H,OAAO4B,GAAG3G,GACpBiJ,GAAMjJ,GAAKA,EAAImJ,GAAQA,GAAMnJ,GAAKA,EAAIiJ,IACxClJ,GAAMmJ,EAAKF,IAAOhJ,EAAIiJ,IAAQE,EAAKF,GAAMD,IACzCD,GAAUA,GAGlB,OAAOA,GCpBA,MAAMK,EACjB,iBACA,YACA,MAOA,YAAYC,EAAmBC,EAAmB,GAC9CrM,KAAKqM,iBAAmBA,EAExB,MAAMC,EAAWF,EAAkBG,KAAKC,IACpC,MAAMC,EAAUD,EAAWD,KAAKpE,GAAM,IAAInB,EAAQmB,EAAErF,EAAGqF,EAAEpF,KACzD,OAAO,IAAI2I,EAAQe,MAEvBzM,KAAK0M,YAAcJ,EAASC,KAAI,CAAChF,EAASxF,IAAM,IAAIsF,EAAQtF,EAAGwF,KAC/DvH,KAAK2M,qBAEL3M,KAAKU,MAAQ,IC9BrB,MACI,MACA,KAAO,GACP,YAAYgM,GACR1M,KAAKyD,MAAQiJ,EACb1M,KAAK6D,OAET,UAAU2E,GACN,OAAOA,EAAW1G,UAEtB,aAAa8K,EAAaC,GACtB,OAAOD,EAAYnE,iBAAiBoE,GAExC,UACI7M,KAAKc,aACLd,KAAKyD,MAAQ,GAEjB,KAAO,8BAAkCzD,MACzC,WAAa,oCAAwCA,MACrD,UAAY,mCAAuCA,MACnD,SAAW,kCAAsCA,ODUnBA,KAAK0M,aAKnC,cACI,OAAO1M,KAAK0M,YAKhB,UACI1M,KAAKU,MAAMoM,UACX,IAAK,MAAMC,KAAQ/M,KAAK0M,YACpBK,EAAKD,UACT9M,KAAK0M,YAAc,GAMvB,cAAc3E,GACV,OAAO/H,KAAK0M,YAAYM,MAAMC,GAAYA,EAAQjF,SAASD,KAa/D,qBAAqBA,EAAOmF,EAAmBC,OAAOC,mBAClD,IAAIC,EAAcH,EACdI,EAAc,KACdC,EAAqB,KACzB,IAAK,MAAMN,KAAWjN,KAAK0M,YAAa,CAEpC,GAAIO,EAAQjF,SAASD,GAAQ,CACzBsF,EAAc,EACdC,EAAcL,EACdM,EAAqBxF,EACrB,MAKJ,MAAMnB,EAAIqG,EAAQrF,eAElB,GADUqF,EAAQvF,SAASW,SAASN,GAC5BnB,EAAIyG,EAAa,CACrB,MAAM1I,EAAS3E,KAAKwN,sBAAsBzF,EAAOkF,GAC7CtI,EAAO0D,SAAWgF,IAClBA,EAAc1I,EAAO0D,SACrBiF,EAAcL,EACdM,EAAqB5I,EAAOoD,QAIxC,MAAO,CAAEM,SAAUgF,EAAa9F,QAAS+F,EAAavF,MAAOwF,GAQjE,SAASE,EAAYC,GACjB,IAII1H,EAAGY,EAJH+G,EAAY,KACZC,EAAU,KACVC,EAAgBV,OAAOW,UACvBC,EAAcZ,OAAOW,UAEzB,MAAME,EAAc,IAAIhH,EAAQyG,EAAW3K,EAAG2K,EAAW1K,GACnDkL,EAAY,IAAIjH,EAAQ0G,EAAS5K,EAAG4K,EAAS3K,GAEnD,IAAK,MAAMkK,KAAWjN,KAAK0M,YACvB9F,EAAIqG,EAAQrF,eAEZ5B,EAAIiH,EAAQvF,SAASW,SAAS2F,GAC1BhI,GAAK6H,GAAiB7H,GAAKY,GAAKqG,EAAQjF,SAASgG,KACjDL,EAAYV,EACZY,EAAgB7H,GAGpBA,EAAIiH,EAAQvF,SAASW,SAAS4F,GAC1BjI,GAAK+H,GAAe/H,GAAKY,GAAKqG,EAAQjF,SAASiG,KAC/CL,EAAUX,EACVc,EAAc/H,GAKtB,IAAK4H,GAAW5N,KAAKqM,iBAAmB,EACpC,IAAK,MAAMY,KAAWjN,KAAK0M,YAGvB,GAFA9F,EAAIqG,EAAQrF,eAAiB5H,KAAKqM,iBAClCrG,EAAIiH,EAAQvF,SAASW,SAAS4F,GAC1BjI,GAAKY,EAAG,CACR,MAAM,SAAEyB,GAAarI,KAAKwN,sBAAsBS,EAAWhB,GACvD5E,GAAYrI,KAAKqM,kBAAoBhE,EAAW0F,IAChDH,EAAUX,EACVc,EAAc1F,GAO9B,IAAKuF,EACD,OAAO,KAEX,IAAKD,GAAa3N,KAAKqM,iBAAmB,EACtC,IAAK,MAAMY,KAAWjN,KAAK0M,YAIvB,GAFA9F,EAAIqG,EAAQrF,eAAiB5H,KAAKqM,iBAClCrG,EAAIiH,EAAQvF,SAASW,SAAS2F,GAC1BhI,GAAKY,EAAG,CAGR,MAAM,SAAEyB,GAAarI,KAAKwN,sBAAsBQ,EAAaf,GACzD5E,GAAYrI,KAAKqM,kBAAoBhE,EAAWwF,IAChDF,EAAYV,EACZY,EAAgBxF,GAMhC,IAAKsF,EACD,OAAO,KAEX,GAAIA,IAAcC,EACd,MAAO,CAACI,EAAaC,GAEzB,MAAMC,EAAY,iBAAqBlO,KAAKU,MAAOiN,EAAWC,EAAS,CACnE7M,UAAWf,KAAKU,MAAMyN,eAG1B,GAAyB,IAArBD,EAAUjM,OACV,OAAO,KAEXiM,EAAU3N,QAAQoN,GAElB,MAAMS,EAAU,IAAIhE,EACpBgE,EAAQ3M,KAAKuM,GACb,IAAK,IAAIjM,EAAI,EAAGA,EAAImM,EAAUjM,OAAS,EAAGF,IAAK,CAC3C,MAAMyG,EAAa0F,EAAUnM,GACvBsM,EAAiBH,EAAUnM,EAAI,GAErC,IAAIuM,EAAS,KACb,IAAK,IAAIvM,EAAI,EAAGA,EAAIyG,EAAW1G,UAAUG,OAAQF,IACzCyG,EAAW1G,UAAUC,GAAGuF,KAAO+G,EAAe/G,KAC9CgH,EAAS9F,EAAWf,QAAQ1F,IAGpC,IAAKuM,EACD,MAAM,IAAIC,MAAM,yDAEpBH,EAAQ3M,KAAK6M,EAAO3N,MAAO2N,EAAO1N,KAEtCwN,EAAQ3M,KAAKwM,GAEbG,EAAQI,aAER,IAAIC,EAAY,KAChB,MAAMC,EAAa,GACnB,IAAK,MAAMvG,KAAKiG,EAAQ/N,KAAM,CAC1B,MAAMsO,EAAWxG,EAAEyG,QACdH,GAAcE,EAAS3D,OAAOyD,IAC/BC,EAAWjN,KAAKkN,GACpBF,EAAYE,EAEhB,OAAOD,EAEX,qBAEI,IAAK,IAAI3M,EAAI,EAAGA,EAAI/B,KAAK0M,YAAYzK,OAAQF,IAAK,CAC9C,MAAMkL,EAAUjN,KAAK0M,YAAY3K,GACjC,IAAK,IAAI2H,EAAI3H,EAAI,EAAG2H,EAAI1J,KAAK0M,YAAYzK,OAAQyH,IAAK,CAClD,MAAMmF,EAAe7O,KAAK0M,YAAYhD,GAGtC,KADUuD,EAAQvF,SAASW,SAASwG,EAAanH,UACzCuF,EAAQrF,eAAiBiH,EAAajH,gBAG9C,IAAK,MAAMU,KAAQ2E,EAAQzF,MACvB,IAAK,MAAMsH,KAAaD,EAAarH,MAAO,CAExC,IAAKoC,EAAatB,EAAMwG,GACpB,SAEJ,MAAMC,EAAU/O,KAAKgP,kBAAkB1G,EAAMwG,GAC7C,IAAKC,EACD,SAEJ9B,EAAQnL,UAAUL,KAAKoN,GACvBA,EAAa/M,UAAUL,KAAKwL,GAG5B,MAAO5C,EAAIC,GAAMyE,EACjB,IAAIE,EAAiBhC,EAAQvF,SAASwH,MAAM5G,EAAK3H,OAC7CwO,EAAKlC,EAAQvF,SAASwH,MAAMH,EAAQ,IACpCK,EAAKnC,EAAQvF,SAASwH,MAAMH,EAAQ,IACpC5L,EAAKqG,EAAgByF,EAAgBE,GACrC/L,EAAKoG,EAAgByF,EAAgBG,GACrCjM,EAAKC,EACL6J,EAAQxF,QAAQhG,KAAK,IAAIwJ,EAAKZ,EAAGvH,EAAGuH,EAAGtH,EAAGuH,EAAGxH,EAAGwH,EAAGvH,IAGnDkK,EAAQxF,QAAQhG,KAAK,IAAIwJ,EAAKX,EAAGxH,EAAGwH,EAAGvH,EAAGsH,EAAGvH,EAAGuH,EAAGtH,IAEvDkM,EAAiBJ,EAAanH,SAASwH,MAAMJ,EAAUnO,OACvDwO,EAAKN,EAAanH,SAASwH,MAAMH,EAAQ,IACzCK,EAAKP,EAAanH,SAASwH,MAAMH,EAAQ,IACzC5L,EAAKqG,EAAgByF,EAAgBE,GACrC/L,EAAKoG,EAAgByF,EAAgBG,GACjCjM,EAAKC,EACLyL,EAAapH,QAAQhG,KAAK,IAAIwJ,EAAKZ,EAAGvH,EAAGuH,EAAGtH,EAAGuH,EAAGxH,EAAGwH,EAAGvH,IAGxD8L,EAAapH,QAAQhG,KAAK,IAAIwJ,EAAKX,EAAGxH,EAAGwH,EAAGvH,EAAGsH,EAAGvH,EAAGuH,EAAGtH,OAWhF,kBAAkB8G,EAAOC,GACrB,MAAMhC,EAAS,CACX,CAAEa,KAAMkB,EAAO9B,MAAO8B,EAAMlJ,OAC5B,CAAEgI,KAAMkB,EAAO9B,MAAO8B,EAAMjJ,KAC5B,CAAE+H,KAAMmB,EAAO/B,MAAO+B,EAAMnJ,OAC5B,CAAEgI,KAAMmB,EAAO/B,MAAO+B,EAAMlJ,MAEhCkH,EAAOuH,MAAK,SAAUpJ,EAAG2C,GACrB,OAAI3C,EAAE8B,MAAMjF,EAAI8F,EAAEb,MAAMjF,GACZ,EACHmD,EAAE8B,MAAMjF,EAAI8F,EAAEb,MAAMjF,EAClB,EAEHmD,EAAE8B,MAAMhF,EAAI6F,EAAEb,MAAMhF,GACZ,EACHkD,EAAE8B,MAAMhF,EAAI6F,EAAEb,MAAMhF,EAClB,EAEA,KAInB,MAAMuM,EAAYxH,EAAO,GAAGa,OAASb,EAAO,GAAGa,KAGzC4G,EAAqBzH,EAAO,GAAGC,MAAMiD,OAAOlD,EAAO,GAAGC,OAC5D,OAAIuH,GAAaC,EACN,KAEA,CAACzH,EAAO,GAAGC,MAAOD,EAAO,GAAGC,OAS3C,sBAAsBA,EAAOkF,GACzB,IAAIuC,EAAoB,KACpBC,EAAkBtC,OAAOW,UAC7B,IAAK,MAAMxF,KAAQ2E,EAAQzF,MAAO,CAC9B,MAAMkI,EAAiBhH,EAAmBX,EAAOO,GAC3CtC,EAAI+B,EAAMM,SAASqH,IACC,OAAtBF,GAA8BxJ,EAAIyJ,KAClCA,EAAkBzJ,EAClBwJ,EAAoBE,GAG5B,MAAO,CAAE3H,MAAOyH,EAAmBnH,SAAUoH,IEhU9C,MAAME,EACT,MACA,OACA,UACA,WACA,IACA,eACA,YAAYpD,EAAKqD,EAAYC,EAAWC,GACpC9P,KAAKuM,IAAMA,EACXvM,KAAK+P,eAAiBH,EACtB5P,KAAKgQ,OAASzD,EAAItK,OAClBjC,KAAKiQ,MAAQ1D,EAAI,GAAGtK,OACpBjC,KAAK6P,UAAYA,EACjB7P,KAAK8P,WAAaA,EAEtB,QAAQI,GACJlQ,KAAKuM,IAAIrE,SAAQ,CAACvE,EAAKZ,KACnBY,EAAIuE,SAAQ,CAACiI,EAAKrN,KACdoN,EAAGpN,EAAGC,EAAG/C,KAAKuM,IAAIxJ,GAAGD,UAIjC,SAASA,EAAGC,GACR,OAAOD,GAAK,GAAKA,EAAI9C,KAAKiQ,OAASlN,GAAK,GAAKA,EAAI/C,KAAKgQ,OAE1D,WAAWlN,EAAGC,GACV,OAAO/C,KAAKoQ,SAAStN,EAAGC,IAAM/C,KAAK+P,eAAe/P,KAAKuM,IAAIxJ,GAAGD,GAAIA,EAAGC,GAEzE,UAAUD,EAAGC,GACT,OAAO/C,KAAKoQ,SAAStN,EAAGC,KAAO/C,KAAK+P,eAAe/P,KAAKuM,IAAIxJ,GAAGD,GAAIA,EAAGC,GAE1E,iBAAiBsN,EAAQC,GACrB,OAAOtQ,KAAKuQ,UAAUvQ,KAAKwQ,SAASH,GAASrQ,KAAKyQ,SAASH,IAE/D,SAASD,GACL,OAAOzN,KAAK+G,MAAM0G,EAASrQ,KAAK6P,WAEpC,SAASS,GACL,OAAO1N,KAAK+G,MAAM2G,EAAStQ,KAAK8P,YAEpC,UAAUO,EAAQC,GACd,MAAO,CAAExN,EAAG9C,KAAKwQ,SAASH,GAAStN,EAAG/C,KAAKyQ,SAASH,IAExD,UAAUI,GACN,OAAOA,EAAQ1Q,KAAK6P,UAExB,UAAUc,GACN,OAAOA,EAAQ3Q,KAAK8P,WAExB,WAAWY,EAAOC,GACd,MAAO,CAAE7N,EAAG9C,KAAK4Q,UAAUF,GAAQ3N,EAAG/C,KAAK6Q,UAAUF,KC/CtD,MAAMG,EACT,KAAO,GACP,IAAI/I,GACA/H,KAAK+Q,KAAKtP,KAAKsG,GAEnB,QACI,OAAO/H,KAAK+Q,KAAKC,QAErB,UACI,OAA4B,IAArBhR,KAAK+Q,KAAK9O,OAErB,cAAc8F,GACV,YAAqEnC,IAA9D5F,KAAK+Q,KAAKE,MAAM9I,GAAMA,EAAErF,IAAMiF,EAAMjF,GAAKqF,EAAEpF,IAAMgF,EAAMhF,IAElE,kBAAkB+E,GACd,OAAOA,EAAOoJ,OAAO/I,GAAMnI,KAAKmR,cAAchJ,KAElD,gBAAgBJ,GACZ,OAAO/H,KAAK+Q,KAAKK,WAAWjJ,GAAMA,EAAErF,GAAKiF,EAAMjF,GAAKqF,EAAEpF,GAAKgF,EAAMhF,IAErE,YAAYgF,GACR,MAAMsJ,EAAQrR,KAAKsR,gBAAgBvJ,IACpB,IAAXsJ,GACArR,KAAK+Q,KAAKQ,OAAOF,EAAO,GAEhC,aAAavJ,GACTA,EAAOI,SAASC,GAAMnI,KAAKwR,YAAYrJ,MC1BxC,MAAMsJ,EACT,EACA,EACA,MACA,OACA,YAAY3O,EAAGC,EAAGkN,EAAOD,GACrBhQ,KAAK8C,EAAIA,EACT9C,KAAK+C,EAAIA,EACT/C,KAAKiQ,MAAQA,EACbjQ,KAAKgQ,OAASA,EAElB,YAAYlN,EAAGC,GACX/C,KAAK8C,EAAIA,EACT9C,KAAK+C,EAAIA,EAEb,QAAQkN,EAAOD,GACXhQ,KAAKiQ,MAAQA,EACbjQ,KAAKgQ,OAASA,EAElB,IAAIzF,EAAMgB,EAAK0E,EAAOD,GAClBhQ,KAAK0R,YAAYnH,EAAMgB,GACvBvL,KAAK2R,QAAQ1B,EAAOD,GAExB,WACI,OAAOhQ,KAAK8C,EAEhB,SAAS8O,GACL5R,KAAK8C,EAAI8O,EAEb,UACI,OAAO5R,KAAK+C,EAEhB,QAAQ6O,GACJ5R,KAAK+C,EAAI6O,EAGb,YACI,OAAO5R,KAAK8C,EAAI9C,KAAKiQ,MAEzB,UAAU2B,GACN5R,KAAKiQ,MAAQ2B,EAAM5R,KAAK8C,EAE5B,aACI,OAAO9C,KAAK+C,EAAI/C,KAAKgQ,OAEzB,WAAW4B,GACP5R,KAAKgQ,OAAS4B,EAAM5R,KAAKuL,IAE7B,aACI,MAAO,CAAEzI,GAAI9C,KAAK8C,EAAI9C,KAAKwK,OAAS,EAAGzH,GAAI/C,KAAK+C,EAAI/C,KAAKwL,QAAU,GAEvE,YAAYqG,GACR,QAAS7R,KAAKwK,MAAQqH,EAAU/O,GAC5B9C,KAAK8C,EAAI+O,EAAUrH,OACnBxK,KAAK+C,EAAI8O,EAAUrG,QACnBxL,KAAKwL,OAASqG,EAAU9O,GAOhC,eAAe8O,GACX,MAAMC,EAAkB9R,KAAK8C,IAAM+O,EAAU/O,GAAK9C,KAAKiQ,QAAU4B,EAAU5B,MACrE8B,EAAgB/R,KAAK+C,IAAM8O,EAAU9O,GAAK/C,KAAKgQ,SAAW6B,EAAU7B,OAC1E,OAAI8B,GAAmB9R,KAAKuL,MAAQsG,EAAUrG,QAC1CxL,KAAKgQ,QAAU6B,EAAU7B,OACzBhQ,KAAK+C,EAAI8O,EAAU9O,GACZ,GAEP+O,GAAmB9R,KAAKwL,SAAWqG,EAAUtG,KAC7CvL,KAAKwL,OAASqG,EAAUrG,QACjB,GAEPuG,GAAiB/R,KAAKuK,OAASsH,EAAUrH,OACzCxK,KAAKiQ,OAAS4B,EAAU5B,MACxBjQ,KAAK8C,EAAI+O,EAAU/O,GACZ,MAEPiP,GAAiB/R,KAAKwK,QAAUqH,EAAUtH,OAC1CvK,KAAKwK,MAAQqH,EAAUrH,MAChB,IAIf,WACI,MAAM,KAAED,EAAI,MAAEC,EAAK,IAAEe,EAAG,OAAEC,GAAWxL,KACrC,MAAO,CACH,CAAE8C,EAAGyH,EAAMxH,EAAGwI,GACd,CAAEzI,EAAG0H,EAAOzH,EAAGwI,GACf,CAAEzI,EAAG0H,EAAOzH,EAAGyI,GACf,CAAE1I,EAAGyH,EAAMxH,EAAGyI,KCpEX,SAASwG,EAAsBzF,EAAKsD,EAAY,EAAGC,EAAa,EAAGF,EAAa3F,EAAUgI,EAAe,GACpH,MAAMC,EAAU,IAAIvC,EAAQpD,EAAKqD,EAAYC,EAAWC,GACxD,GAAImC,GAAgBpC,GAAaoC,GAAgBnC,EAC7C,MAAM,IAAIvB,MAAM,sCAAsC0D,+CAE1D,IAAIE,EAYR,SAA2BD,GACvB,MAAME,EAAgB,IAAItB,GACpB,UAAEjB,EAAS,WAAEC,GAAeoC,EAC5BC,EAAQ,GACd,IAAIE,EACJH,EAAQhK,SAAQ,CAACpF,EAAGC,KACZmP,EAAQtC,WAAW9M,EAAGC,IACtBqP,EAAchK,IAAI,CAAEtF,IAAGC,SAE/B,MAoCMuP,EAAmB,CAACC,EAAMC,KAC5B,MAAMC,EArCiB,EAACF,EAAMC,KAC9B,MAAM,IAAEjH,EAAG,KAAEhB,EAAI,MAAEC,EAAK,OAAEgB,GAAW+G,EACrC,IAAIzK,EAAS,GACb,GAAY,QAAR0K,EACA,IAAK,IAAI1P,EAAIyH,EAAMzH,GAAK0H,EAAQ,EAAG1H,IAC/BgF,EAAOrG,KAAK,CAAEqB,IAAGC,EAAGwI,SAEvB,GAAY,WAARiH,EACL,IAAK,IAAI1P,EAAIyH,EAAMzH,GAAK0H,EAAQ,EAAG1H,IAC/BgF,EAAOrG,KAAK,CAAEqB,IAAGC,EAAGyI,SAEvB,GAAY,SAARgH,EACL,IAAK,IAAIzP,EAAIwI,EAAKxI,GAAKyI,EAAS,EAAGzI,IAC/B+E,EAAOrG,KAAK,CAAEqB,EAAGyH,EAAMxH,UAE1B,IAAY,UAARyP,EAKL,MAAM,IAAIjE,MAAM,gBAAgBiE,iBAJhC,IAAK,IAAIzP,EAAIwI,EAAKxI,GAAKyI,EAAS,EAAGzI,IAC/B+E,EAAOrG,KAAK,CAAEqB,EAAG0H,EAAOzH,MAKhC,OAAO+E,GAegB4K,CAAmBH,EAAMC,GAC1CG,EAAYP,EAAcQ,kBAAkBH,GAKlD,OAJIE,IAfsB,EAACJ,EAAMC,KACjC,GAAY,QAARA,EACAD,EAAKxP,GAAK,OACT,GAAY,WAARyP,EACLD,EAAK/G,QAAU,OACd,GAAY,SAARgH,EACLD,EAAKzP,GAAK,MACT,IAAY,UAAR0P,EAGL,MAAM,IAAIjE,MAAM,gBAAgBiE,iBAFhCD,EAAK/H,OAAS,IAQdqI,CAAsBN,EAAMC,GAC5BJ,EAAcU,aAAaL,IAExBE,GAEX,MAAQP,EAAcW,WAAW,CAE7B,MAAMC,EAAOZ,EAAcpB,QAC3B,QAAapL,IAAToN,EACA,MAEJX,EAAc,IAAIZ,EAAcuB,EAAKlQ,EAAGkQ,EAAKjQ,EAAG,EAAG,GAEnD,IAAIkQ,GAAsB,EAC1B,KAAOA,GAAqB,CACxB,MAAMC,EAAcZ,EAAiBD,EAAa,OAC5Cc,EAAgBb,EAAiBD,EAAa,SAC9Ce,EAAed,EAAiBD,EAAa,QAC7CgB,EAAiBf,EAAiBD,EAAa,UACrDY,EAAsBC,GAAeG,GAAkBD,GAAgBD,EAG3Ed,EAAYX,YAAYW,EAAYvP,EAAI+M,EAAWwC,EAAYtP,EAAI+M,GACnEuC,EAAYV,QAAQU,EAAYpC,MAAQJ,EAAWwC,EAAYrC,OAASF,GACxEqC,EAAM1Q,KAAK4Q,GAEf,OAAOF,EAvFKmB,CAAkBpB,GAI9B,OAHID,EAAe,IACfE,EA6KR,SAAqBA,EAAOD,EAASD,GACjC,MAAM,WAAEnC,EAAU,UAAED,GAAcqC,EAC5BqB,EAAW,GACXC,EAAa,GACnBrB,EAAMjK,SAAQ,CAACqK,EAAMkB,KACjB,MAAMC,EAAK5D,EACL6D,EAAK9D,EACL+D,EAAQ1B,EAAQ1B,SAAS+B,EAAKzP,GAC9B+Q,EAAO3B,EAAQzB,SAAS8B,EAAKxP,GAC7B+Q,EAAU5B,EAAQzB,SAAS8B,EAAK/G,QAChCuI,EAAS7B,EAAQ1B,SAAS+B,EAAK/H,OAC/BwJ,EAASC,EAAW1B,EAAML,EAASD,EAAcpC,EAAWC,GAClE,GAAIyC,EAAKhI,MAAQgI,EAAK/H,OAAS+H,EAAKhH,KAAOgH,EAAK/G,OAC5C,OACJgI,EAAW/R,KAAK8Q,GAChB,MAAM2B,EAAmB,GACnBC,EAAqB,GACrBC,EAAU,CAACtR,EAAGC,EAAGsR,EAAG9S,KACtB,MAAMgR,EAAO,IAAId,EAAc3O,EAAGC,EAAGsR,EAAG9S,GACpC8S,EAAI9S,EACJ4S,EAAmB1S,KAAK8Q,GAExB2B,EAAiBzS,KAAK8Q,IAE9B,GAAIyB,EAAOzJ,KAAM,CACb,MAAMzH,EAAIyP,EAAKhI,KAAO0H,EACtB,IAAIqC,EAAST,EACTU,EAAOD,EAAS,EACpB,IAAK,IAAIvR,EAAI8Q,EAAM9Q,EAAI+Q,EAAS/Q,IACxBmP,EAAQ3B,UAAUqD,EAAQ,EAAG7Q,IACzBuR,GAAUC,GACVH,EAAQtR,EAAGwR,EAASZ,EAAIzB,GAAesC,EAAOD,EAAS,GAAKZ,GAEhEY,EAASvR,EAAI,GAGbwR,EAAOxR,EAGXuR,GAAUC,GACVH,EAAQtR,EAAGwR,EAASZ,EAAIzB,GAAesC,EAAOD,EAAS,GAAKZ,GAGpE,GAAIM,EAAOxJ,MAAO,CACd,MAAM1H,EAAIyP,EAAK/H,MACf,IAAI8J,EAAST,EACTU,EAAOD,EAAS,EACpB,IAAK,IAAIvR,EAAI8Q,EAAM9Q,EAAI+Q,EAAS/Q,IACxBmP,EAAQ3B,UAAUwD,EAAQhR,IACtBuR,GAAUC,GACVH,EAAQtR,EAAGwR,EAASZ,EAAIzB,GAAesC,EAAOD,EAAS,GAAKZ,GAEhEY,EAASvR,EAAI,GAGbwR,EAAOxR,EAGXuR,GAAUC,GACVH,EAAQtR,EAAGwR,EAASZ,EAAIzB,GAAesC,EAAOD,EAAS,GAAKZ,GAGpE,GAAIM,EAAOzI,IAAK,CACZ,MAAMxI,EAAIwP,EAAKhH,IAAM0G,EACrB,IAAIuC,EAASZ,EACTa,EAAOD,EAAS,EACpB,IAAK,IAAI1R,EAAI8Q,EAAO9Q,EAAIiR,EAAQjR,IACxBoP,EAAQ3B,UAAUzN,EAAG+Q,EAAO,IACxBW,GAAUC,GACVL,EAAQI,EAASb,EAAI5Q,GAAI0R,EAAOD,EAAS,GAAKd,EAAIzB,GAEtDuC,EAAS1R,EAAI,GAGb2R,EAAO3R,EAGX0R,GAAUC,GACVL,EAAQI,EAASb,EAAI5Q,GAAI0R,EAAOD,EAAS,GAAKd,EAAIzB,GAG1D,GAAI+B,EAAOxI,OAAQ,CACf,MAAMzI,EAAIwP,EAAK/G,OACf,IAAIgJ,EAASZ,EACTa,EAAOD,EAAS,EACpB,IAAK,IAAI1R,EAAI8Q,EAAO9Q,EAAIiR,EAAQjR,IACxBoP,EAAQ3B,UAAUzN,EAAGgR,IACjBU,GAAUC,GACVL,EAAQI,EAASb,EAAI5Q,GAAI0R,EAAOD,EAAS,GAAKd,EAAIzB,GAEtDuC,EAAS1R,EAAI,GAGb2R,EAAO3R,EAGX0R,GAAUC,GACVL,EAAQI,EAASb,EAAI5Q,GAAI0R,EAAOD,EAAS,GAAKd,EAAIzB,GAI1DkC,EAAmBjM,SAASwM,IACxBR,EAAiBhM,SAASyM,IAClBD,EAAGE,YAAYD,KACMD,EAAG3R,EAAI4R,EAAG5R,EAE3B4R,EAAG3E,QAAUiC,EAEb0C,EAAGpJ,KAAO0G,SAI1B,IAAIkC,KAAuBD,GAAkBhM,SAASqK,IAClD0B,EAAW1B,EAAML,EAASD,EAAcpC,EAAWC,GAC/CyC,EAAKhI,MAAQgI,EAAK/H,OAAS+H,EAAKhH,KAAOgH,EAAK/G,QAEhD+H,EAAS9R,KAAK8Q,SAItB,IAAK,IAAIxQ,EAAI,EAAGA,EAAIwR,EAAStR,OAAQF,IAAK,CACtC,IAAI8S,GAAY,EAEhB,IAAK,MAAMC,KAAY3C,EAEnB,GADA0C,EAAYC,EAASC,eAAexB,EAASxR,IACzC8S,EACA,MAER,IAAIA,EAAJ,CAGA,IAAK,IAAInL,EAAI3H,EAAI,EAAG2H,EAAI6J,EAAStR,SAC7B4S,EAAYtB,EAAS7J,GAAGqL,eAAexB,EAASxR,KAC5C8S,GAFiCnL,KAKpCmL,GACDrB,EAAW/R,KAAK8R,EAASxR,KAEjC,OAAOyR,EAxTKwB,CAAY7C,EAAOD,EAASD,IAEjCE,EAAM5F,KAAKgG,GAASA,EAAK0C,aAsFpC,SAAShB,EAAW1B,EAAML,EAASD,EAAcpC,EAAWC,GACxD,MAAMoF,EAAIjD,EACJkD,EAAYtF,EAAY,EACxBuF,EAAatF,EAAa,GAC1B,KAAEvF,EAAI,IAAEgB,EAAG,MAAEf,EAAK,OAAEgB,GAAW+G,EAC/B8C,EAAO,CACT9K,MAAM,EACNC,OAAO,EACPe,KAAK,EACLC,QAAQ,EACR8J,QAASpD,EAAQqD,iBAAiBhL,EAAO2K,EAAG3J,EAAM2J,GAClDM,SAAUtD,EAAQqD,iBAAiB/K,EAAQ0K,EAAG3J,EAAM2J,GACpDO,WAAYvD,EAAQqD,iBAAiBhL,EAAO2K,EAAG1J,EAAS0J,GACxDQ,YAAaxD,EAAQqD,iBAAiB/K,EAAQ0K,EAAG1J,EAAS0J,IAE9D,IAAK,IAAInS,EAAIwI,EAAM6J,EAAYrS,EAAIyI,EAAQzI,GAAKqS,EAC5C,GAAIlD,EAAQqD,iBAAiBhL,EAAO2K,EAAGnS,GAAI,CACvCsS,EAAK9K,MAAO,EACZ,MAGR,IAAK,IAAIxH,EAAIwI,EAAM6J,EAAYrS,EAAIyI,EAAQzI,GAAKqS,EAC5C,GAAIlD,EAAQqD,iBAAiB/K,EAAQ0K,EAAGnS,GAAI,CACxCsS,EAAK7K,OAAQ,EACb,MAGR,IAAK,IAAI1H,EAAIyH,EAAO4K,EAAWrS,EAAI0H,EAAO1H,GAAKqS,EAC3C,GAAIjD,EAAQqD,iBAAiBzS,EAAGyI,EAAM0G,GAAe,CACjDoD,EAAK9J,KAAM,EACX,MAGR,IAAK,IAAIzI,EAAIyH,EAAO4K,EAAWrS,EAAI0H,EAAO1H,GAAKqS,EAC3C,GAAIjD,EAAQqD,iBAAiBzS,EAAG0I,EAASyG,GAAe,CACpDoD,EAAK7J,QAAS,EACd,MAGR,MAAMwI,EAAS,CACXzJ,KAAM8K,EAAK9K,KACXC,MAAO6K,EAAK7K,MACZe,IAAK8J,EAAK9J,IACVC,OAAQ6J,EAAK7J,QAwCjB,OAtCI6J,EAAKC,SAAYD,EAAK9K,MAAS8K,EAAK9J,MAChCgH,EAAKtC,MAAQsC,EAAKvC,OAClBgE,EAAOzJ,MAAO,EAEdyJ,EAAOzI,KAAM,IAEjB8J,EAAKG,UAAaH,EAAK7K,OAAU6K,EAAK9J,MAClCgH,EAAKtC,MAAQsC,EAAKvC,OAClBgE,EAAOxJ,OAAQ,EAEfwJ,EAAOzI,KAAM,IAEjB8J,EAAKI,YAAeJ,EAAK7J,QAAW6J,EAAK9K,OACrCgI,EAAKtC,MAAQsC,EAAKvC,OAClBgE,EAAOzJ,MAAO,EAEdyJ,EAAOxI,QAAS,IAEpB6J,EAAKK,aAAgBL,EAAK7J,QAAW6J,EAAK7K,QACtC+H,EAAKtC,MAAQsC,EAAKvC,OAClBgE,EAAOxJ,OAAQ,EAEfwJ,EAAOxI,QAAS,GAEpBwI,EAAOzJ,OACPgI,EAAKzP,GAAKmP,EACVM,EAAKtC,OAASgC,GAEd+B,EAAOzI,MACPgH,EAAKxP,GAAKkP,EACVM,EAAKvC,QAAUiC,GAEf+B,EAAOxJ,QACP+H,EAAKtC,OAASgC,GAEd+B,EAAOxI,SACP+G,EAAKvC,QAAUiC,GAEZ+B,ECnMX,W","file":"navmesh.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NavMesh\"] = factory();\n\telse\n\t\troot[\"NavMesh\"] = factory();\n})((typeof self !== \"undefined\" ? self : this), function() {\nreturn ","// javascript-astar 0.4.2\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n(function(definition) {\n  /* global module, define */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = definition();\n  } else if (typeof define === 'function' && define.amd) {\n    define([], definition);\n  } else {\n    var exports = definition();\n    window.astar = exports.astar;\n    window.Graph = exports.Graph;\n  }\n})(function() {\n\nfunction pathTo(node) {\n  var curr = node;\n  var path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function(node) {\n    return node.f;\n  });\n}\n\nvar astar = {\n  /**\n  * Perform an A* Search on a graph given a start and end node.\n  * @param {Graph} graph\n  * @param {GridNode} start\n  * @param {GridNode} end\n  * @param {Object} [options]\n  * @param {bool} [options.closest] Specifies whether to return the\n             path to the closest node if the target is unreachable.\n  * @param {Function} [options.heuristic] Heuristic function (see\n  *          astar.heuristics).\n  */\n  search: function(graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\n    var closest = options.closest || false;\n\n    var openHeap = getHeap();\n    var closestNode = start; // set the start node to be the closest if required\n\n    start.h = heuristic(start, end);\n    graph.markDirty(start);\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\n      currentNode.closed = true;\n\n      // Find all neighbors for the current node.\n      var neighbors = graph.neighbors(currentNode);\n\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\n        var beenVisited = neighbor.visited;\n\n        if (!beenVisited || gScore < neighbor.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\n              closestNode = neighbor;\n            }\n          }\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n\n    if (closest) {\n      return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function(pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function(pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\n    }\n  },\n  cleanNode: function(node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n};\n\n/**\n * A graph memory structure\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options]\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\n */\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\n\nGraph.prototype.init = function() {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\n\nGraph.prototype.cleanDirty = function() {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\n\nGraph.prototype.markDirty = function(node) {\n  this.dirtyNodes.push(node);\n};\n\nGraph.prototype.neighbors = function(node) {\n  var ret = [];\n  var x = node.x;\n  var y = node.y;\n  var grid = this.grid;\n\n  // West\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n\n  // East\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n\n  // South\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n\n  // North\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n\n  if (this.diagonal) {\n    // Southwest\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n\n    // Southeast\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n\n    // Northwest\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n\n    // Northeast\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n\n  return ret;\n};\n\nGraph.prototype.toString = function() {\n  var graphString = [];\n  var nodes = this.grid;\n  for (var x = 0; x < nodes.length; x++) {\n    var rowDebug = [];\n    var row = nodes[x];\n    for (var y = 0; y < row.length; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\n\nGridNode.prototype.toString = function() {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function(fromNeighbor) {\n  // Take diagonal weight into consideration.\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\n    return this.weight * 1.41421;\n  }\n  return this.weight;\n};\n\nGridNode.prototype.isWall = function() {\n  return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function(node) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function() {\n    return this.content.length;\n  },\n  rescoreElement: function(node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function(n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n\n      // Compute the parent element's index, and fetch it.\n      var parentN = ((n + 1) >> 1) - 1;\n      var parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      }\n      // Found a parent that is less, no need to sink any further.\n      else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function(n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) << 1;\n      var child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null;\n      var child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n};\n\nreturn {\n  astar: astar,\n  Graph: Graph\n};\n\n});","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\r\n * Stripped down version of Phaser's Vector2 with just the functionality needed for navmeshes.\r\n *\r\n * @export\r\n * @class Vector2\r\n */\r\nexport default class Vector2 {\r\n    x;\r\n    y;\r\n    constructor(x = 0, y = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    equals(v) {\r\n        return this.x === v.x && this.y === v.y;\r\n    }\r\n    angle(v) {\r\n        return Math.atan2(v.y - this.y, v.x - this.x);\r\n    }\r\n    distance(v) {\r\n        const dx = v.x - this.x;\r\n        const dy = v.y - this.y;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    add(v) {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n    }\r\n    subtract(v) {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n    }\r\n    clone() {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n}\r\n","import Vector2 from \"./math/vector-2\";\r\n/**\r\n * A class that represents a navigable polygon with a navmesh. It is built on top of a\r\n * {@link Polygon}. It implements the properties and fields that javascript-astar needs - weight,\r\n * toString, isWall and getCost. See GPS test from astar repo for structure:\r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n */\r\nexport default class NavPoly {\r\n    id;\r\n    polygon;\r\n    edges;\r\n    neighbors;\r\n    portals;\r\n    centroid;\r\n    boundingRadius;\r\n    // jsastar property:\r\n    weight = 1;\r\n    x = 0;\r\n    y = 0;\r\n    /**\r\n     * Creates an instance of NavPoly.\r\n     */\r\n    constructor(id, polygon) {\r\n        this.id = id;\r\n        this.polygon = polygon;\r\n        this.edges = polygon.edges;\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n        this.centroid = this.calculateCentroid();\r\n        this.boundingRadius = this.calculateRadius();\r\n    }\r\n    /**\r\n     * Returns an array of points that form the polygon.\r\n     */\r\n    getPoints() {\r\n        return this.polygon.points;\r\n    }\r\n    /**\r\n     * Check if the given point-like object is within the polygon.\r\n     */\r\n    contains(point) {\r\n        // Phaser's polygon check doesn't handle when a point is on one of the edges of the line. Note:\r\n        // check numerical stability here. It would also be good to optimize this for different shapes.\r\n        return this.polygon.contains(point.x, point.y) || this.isPointOnEdge(point);\r\n    }\r\n    /**\r\n     * Only rectangles are supported, so this calculation works, but this is not actually the centroid\r\n     * calculation for a polygon. This is just the average of the vertices - proper centroid of a\r\n     * polygon factors in the area.\r\n     */\r\n    calculateCentroid() {\r\n        const centroid = new Vector2(0, 0);\r\n        const length = this.polygon.points.length;\r\n        this.polygon.points.forEach((p) => centroid.add(p));\r\n        centroid.x /= length;\r\n        centroid.y /= length;\r\n        return centroid;\r\n    }\r\n    /**\r\n     * Calculate the radius of a circle that circumscribes the polygon.\r\n     */\r\n    calculateRadius() {\r\n        let boundingRadius = 0;\r\n        for (const point of this.polygon.points) {\r\n            const d = this.centroid.distance(point);\r\n            if (d > boundingRadius)\r\n                boundingRadius = d;\r\n        }\r\n        return boundingRadius;\r\n    }\r\n    /**\r\n     * Check if the given point-like object is on one of the edges of the polygon.\r\n     */\r\n    isPointOnEdge({ x, y }) {\r\n        for (const edge of this.edges) {\r\n            if (edge.pointOnSegment(x, y))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    destroy() {\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n    }\r\n    // === jsastar methods ===\r\n    toString() {\r\n        return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n    }\r\n    isWall() {\r\n        return this.weight === 0;\r\n    }\r\n    centroidDistance(navPolygon) {\r\n        return this.centroid.distance(navPolygon.centroid);\r\n    }\r\n    getCost(navPolygon) {\r\n        return this.centroidDistance(navPolygon);\r\n    }\r\n}\r\n","import Vector2 from \"./math/vector-2\";\r\n/**\r\n * Calculate the distance squared between two points. This is an optimization to a square root when\r\n * you just need to compare relative distances without needing to know the specific distance.\r\n * @param a\r\n * @param b\r\n */\r\nexport function distanceSquared(a, b) {\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n    return dx * dx + dy * dy;\r\n}\r\n/**\r\n * Project a point onto a line segment.\r\n * JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n * @param point\r\n * @param line\r\n */\r\nexport function projectPointToEdge(point, line) {\r\n    const a = line.start;\r\n    const b = line.end;\r\n    // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n    // where our point lies on the line by solving for t:\r\n    //  t = [(p-a) . (b-a)] / |b-a|^2\r\n    const l2 = distanceSquared(a, b);\r\n    let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n    // We clamp t from [0,1] to handle points outside the segment vw.\r\n    t = clamp(t, 0, 1);\r\n    // Project onto the segment\r\n    const p = new Vector2(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\r\n    return p;\r\n}\r\n/**\r\n * Twice the area of the triangle formed by a, b and c.\r\n */\r\nexport function triarea2(a, b, c) {\r\n    const ax = b.x - a.x;\r\n    const ay = b.y - a.y;\r\n    const bx = c.x - a.x;\r\n    const by = c.y - a.y;\r\n    return bx * ay - ax * by;\r\n}\r\n/**\r\n * Clamp the given value between min and max.\r\n */\r\nexport function clamp(value, min, max) {\r\n    if (value < min)\r\n        value = min;\r\n    if (value > max)\r\n        value = max;\r\n    return value;\r\n}\r\n/**\r\n * Check if two values are within a small margin of one another.\r\n */\r\nexport function almostEqual(value1, value2, errorMargin = 0.0001) {\r\n    if (Math.abs(value1 - value2) <= errorMargin)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n/**\r\n * Find the smallest angle difference between two angles\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n */\r\nexport function angleDifference(x, y) {\r\n    let a = x - y;\r\n    const i = a + Math.PI;\r\n    const j = Math.PI * 2;\r\n    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n    a -= Math.PI;\r\n    return a;\r\n}\r\n/**\r\n * Check if two lines are collinear (within a small error margin).\r\n */\r\nexport function areCollinear(line1, line2, errorMargin = 0.0001) {\r\n    // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n    // by their points\r\n    const area1 = triarea2(line1.start, line1.end, line2.start);\r\n    const area2 = triarea2(line1.start, line1.end, line2.end);\r\n    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\nexport function isTruthy(input) {\r\n    return Boolean(input);\r\n}\r\n","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\nimport { triarea2 } from \"./utils\";\r\n/**\r\n * @private\r\n */\r\nexport default class Channel {\r\n    path;\r\n    portals;\r\n    constructor() {\r\n        this.portals = [];\r\n        this.path = [];\r\n    }\r\n    push(p1, p2) {\r\n        if (p2 === undefined)\r\n            p2 = p1;\r\n        this.portals.push({\r\n            left: p1,\r\n            right: p2,\r\n        });\r\n    }\r\n    stringPull() {\r\n        const portals = this.portals;\r\n        const pts = [];\r\n        // Init scan state\r\n        let apexIndex = 0;\r\n        let leftIndex = 0;\r\n        let rightIndex = 0;\r\n        let portalApex = portals[0].left;\r\n        let portalLeft = portals[0].left;\r\n        let portalRight = portals[0].right;\r\n        // Add start point.\r\n        pts.push(portalApex);\r\n        for (var i = 1; i < portals.length; i++) {\r\n            // Find the next portal vertices\r\n            const left = portals[i].left;\r\n            const right = portals[i].right;\r\n            // Update right vertex.\r\n            if (triarea2(portalApex, portalRight, right) <= 0.0) {\r\n                if (portalApex.equals(portalRight) || triarea2(portalApex, portalLeft, right) > 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalRight = right;\r\n                    rightIndex = i;\r\n                }\r\n                else {\r\n                    // Right vertex just crossed over the left vertex, so the left vertex should\r\n                    // now be part of the path.\r\n                    pts.push(portalLeft);\r\n                    // Restart scan from portal left point.\r\n                    // Make current left the new apex.\r\n                    portalApex = portalLeft;\r\n                    apexIndex = leftIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n            // Update left vertex.\r\n            if (triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n                if (portalApex.equals(portalLeft) || triarea2(portalApex, portalRight, left) < 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalLeft = left;\r\n                    leftIndex = i;\r\n                }\r\n                else {\r\n                    // Left vertex just crossed over the right vertex, so the right vertex should\r\n                    // now be part of the path\r\n                    pts.push(portalRight);\r\n                    // Restart scan from portal right point.\r\n                    // Make current right the new apex.\r\n                    portalApex = portalRight;\r\n                    apexIndex = rightIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {\r\n            // Append last point to path.\r\n            pts.push(portals[portals.length - 1].left);\r\n        }\r\n        this.path = pts;\r\n        return pts;\r\n    }\r\n}\r\n","import Vector2 from \"./vector-2\";\r\n/**\r\n * Stripped down version of Phaser's Line with just the functionality needed for navmeshes.\r\n *\r\n * @export\r\n * @class Line\r\n */\r\nexport default class Line {\r\n    start;\r\n    end;\r\n    left;\r\n    right;\r\n    top;\r\n    bottom;\r\n    constructor(x1, y1, x2, y2) {\r\n        this.start = new Vector2(x1, y1);\r\n        this.end = new Vector2(x2, y2);\r\n        this.left = Math.min(x1, x2);\r\n        this.right = Math.max(x1, x2);\r\n        this.top = Math.min(y1, y2);\r\n        this.bottom = Math.max(y1, y2);\r\n    }\r\n    pointOnSegment(x, y) {\r\n        return (x >= this.left &&\r\n            x <= this.right &&\r\n            y >= this.top &&\r\n            y <= this.bottom &&\r\n            this.pointOnLine(x, y));\r\n    }\r\n    pointOnLine(x, y) {\r\n        // Compare slope of line start -> xy to line start -> line end\r\n        return (x - this.left) * (this.bottom - this.top) === (this.right - this.left) * (y - this.top);\r\n    }\r\n}\r\n","import Line from \"./line\";\r\n/**\r\n * Stripped down version of Phaser's Polygon with just the functionality needed for navmeshes.\r\n *\r\n * @export\r\n * @class Polygon\r\n */\r\nexport default class Polygon {\r\n    edges;\r\n    points;\r\n    isClosed;\r\n    constructor(points, closed = true) {\r\n        this.isClosed = closed;\r\n        this.points = points;\r\n        this.edges = [];\r\n        for (let i = 1; i < points.length; i++) {\r\n            const p1 = points[i - 1];\r\n            const p2 = points[i];\r\n            this.edges.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n        }\r\n        if (this.isClosed) {\r\n            const first = points[0];\r\n            const last = points[points.length - 1];\r\n            this.edges.push(new Line(first.x, first.y, last.x, last.y));\r\n        }\r\n    }\r\n    contains(x, y) {\r\n        let inside = false;\r\n        for (let i = -1, j = this.points.length - 1; ++i < this.points.length; j = i) {\r\n            const ix = this.points[i].x;\r\n            const iy = this.points[i].y;\r\n            const jx = this.points[j].x;\r\n            const jy = this.points[j].y;\r\n            if (((iy <= y && y < jy) || (jy <= y && y < iy)) &&\r\n                x < ((jx - ix) * (y - iy)) / (jy - iy) + ix) {\r\n                inside = !inside;\r\n            }\r\n        }\r\n        return inside;\r\n    }\r\n}\r\n","import jsastar from \"javascript-astar\";\r\nimport NavPoly from \"./navpoly\";\r\nimport NavGraph from \"./navgraph\";\r\nimport Channel from \"./channel\";\r\nimport { angleDifference, areCollinear, projectPointToEdge } from \"./utils\";\r\nimport Vector2 from \"./math/vector-2\";\r\nimport Line from \"./math/line\";\r\nimport Polygon from \"./math/polygon\";\r\n/**\r\n * The `NavMesh` class is the workhorse that represents a navigation mesh built from a series of\r\n * polygons. Once built, the mesh can be asked for a path from one point to another point. Some\r\n * internal terminology usage:\r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n */\r\nexport default class NavMesh {\r\n    meshShrinkAmount;\r\n    navPolygons;\r\n    graph;\r\n    /**\r\n     * @param meshPolygonPoints Array where each element is an array of point-like objects that\r\n     * defines a polygon.\r\n     * @param meshShrinkAmount The amount (in pixels) that the navmesh has been shrunk around\r\n     * obstacles (a.k.a the amount obstacles have been expanded).\r\n     */\r\n    constructor(meshPolygonPoints, meshShrinkAmount = 0) {\r\n        this.meshShrinkAmount = meshShrinkAmount;\r\n        // Convert the PolyPoints[] into NavPoly instances.\r\n        const newPolys = meshPolygonPoints.map((polyPoints) => {\r\n            const vectors = polyPoints.map((p) => new Vector2(p.x, p.y));\r\n            return new Polygon(vectors);\r\n        });\r\n        this.navPolygons = newPolys.map((polygon, i) => new NavPoly(i, polygon));\r\n        this.calculateNeighbors();\r\n        // Astar graph of connections between polygons\r\n        this.graph = new NavGraph(this.navPolygons);\r\n    }\r\n    /**\r\n     * Get the NavPolys that are in this navmesh.\r\n     */\r\n    getPolygons() {\r\n        return this.navPolygons;\r\n    }\r\n    /**\r\n     * Cleanup method to remove references.\r\n     */\r\n    destroy() {\r\n        this.graph.destroy();\r\n        for (const poly of this.navPolygons)\r\n            poly.destroy();\r\n        this.navPolygons = [];\r\n    }\r\n    /**\r\n     * Find if the given point is within any of the polygons in the mesh.\r\n     * @param point\r\n     */\r\n    isPointInMesh(point) {\r\n        return this.navPolygons.some((navPoly) => navPoly.contains(point));\r\n    }\r\n    /**\r\n     * Find the closest point in the mesh to the given point. If the point is already in the mesh,\r\n     * this will give you that point. If the point is outside of the mesh, this will attempt to\r\n     * project this point into the mesh (up to the given maxAllowableDist). This returns an object\r\n     * with:\r\n     * - distance - from the given point to the mesh\r\n     * - polygon - the one the point is closest to, or null\r\n     * - point - the point inside the mesh, or null\r\n     * @param point\r\n     * @param maxAllowableDist\r\n     */\r\n    findClosestMeshPoint(point, maxAllowableDist = Number.POSITIVE_INFINITY) {\r\n        let minDistance = maxAllowableDist;\r\n        let closestPoly = null;\r\n        let pointOnClosestPoly = null;\r\n        for (const navPoly of this.navPolygons) {\r\n            // If we are inside a poly, we've got the closest.\r\n            if (navPoly.contains(point)) {\r\n                minDistance = 0;\r\n                closestPoly = navPoly;\r\n                pointOnClosestPoly = point;\r\n                break;\r\n            }\r\n            // Is the poly close enough to warrant a more accurate check? Point is definitely outside of\r\n            // the polygon. Distance - Radius is the smallest possible distance to an edge of the poly.\r\n            // This will underestimate distance, but that's perfectly fine.\r\n            const r = navPoly.boundingRadius;\r\n            const d = navPoly.centroid.distance(point);\r\n            if (d - r < minDistance) {\r\n                const result = this.projectPointToPolygon(point, navPoly);\r\n                if (result.distance < minDistance) {\r\n                    minDistance = result.distance;\r\n                    closestPoly = navPoly;\r\n                    pointOnClosestPoly = result.point;\r\n                }\r\n            }\r\n        }\r\n        return { distance: minDistance, polygon: closestPoly, point: pointOnClosestPoly };\r\n    }\r\n    /**\r\n     * Find a path from the start point to the end point using this nav mesh.\r\n     * @param {object} startPoint A point-like object in the form {x, y}\r\n     * @param {object} endPoint A point-like object in the form {x, y}\r\n     * @returns {Vector2[]|null} An array of points if a path is found, or null if no path\r\n     */\r\n    findPath(startPoint, endPoint) {\r\n        let startPoly = null;\r\n        let endPoly = null;\r\n        let startDistance = Number.MAX_VALUE;\r\n        let endDistance = Number.MAX_VALUE;\r\n        let d, r;\r\n        const startVector = new Vector2(startPoint.x, startPoint.y);\r\n        const endVector = new Vector2(endPoint.x, endPoint.y);\r\n        // Find the closest poly for the starting and ending point\r\n        for (const navPoly of this.navPolygons) {\r\n            r = navPoly.boundingRadius;\r\n            // Start\r\n            d = navPoly.centroid.distance(startVector);\r\n            if (d <= startDistance && d <= r && navPoly.contains(startVector)) {\r\n                startPoly = navPoly;\r\n                startDistance = d;\r\n            }\r\n            // End\r\n            d = navPoly.centroid.distance(endVector);\r\n            if (d <= endDistance && d <= r && navPoly.contains(endVector)) {\r\n                endPoly = navPoly;\r\n                endDistance = d;\r\n            }\r\n        }\r\n        // If the end point wasn't inside a polygon, run a more liberal check that allows a point\r\n        // to be within meshShrinkAmount radius of a polygon\r\n        if (!endPoly && this.meshShrinkAmount > 0) {\r\n            for (const navPoly of this.navPolygons) {\r\n                r = navPoly.boundingRadius + this.meshShrinkAmount;\r\n                d = navPoly.centroid.distance(endVector);\r\n                if (d <= r) {\r\n                    const { distance } = this.projectPointToPolygon(endVector, navPoly);\r\n                    if (distance <= this.meshShrinkAmount && distance < endDistance) {\r\n                        endPoly = navPoly;\r\n                        endDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // No matching polygons locations for the end, so no path found\r\n        // because start point is valid normally, check end point first\r\n        if (!endPoly)\r\n            return null;\r\n        // Same check as above, but for the start point\r\n        if (!startPoly && this.meshShrinkAmount > 0) {\r\n            for (const navPoly of this.navPolygons) {\r\n                // Check if point is within bounding circle to avoid extra projection calculations\r\n                r = navPoly.boundingRadius + this.meshShrinkAmount;\r\n                d = navPoly.centroid.distance(startVector);\r\n                if (d <= r) {\r\n                    // Check if projected point is within range of a polgyon and is closer than the\r\n                    // previous point\r\n                    const { distance } = this.projectPointToPolygon(startVector, navPoly);\r\n                    if (distance <= this.meshShrinkAmount && distance < startDistance) {\r\n                        startPoly = navPoly;\r\n                        startDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // No matching polygons locations for the start, so no path found\r\n        if (!startPoly)\r\n            return null;\r\n        // If the start and end polygons are the same, return a direct path\r\n        if (startPoly === endPoly)\r\n            return [startVector, endVector];\r\n        // Search!\r\n        const astarPath = jsastar.astar.search(this.graph, startPoly, endPoly, {\r\n            heuristic: this.graph.navHeuristic,\r\n        });\r\n        // While the start and end polygons may be valid, no path between them\r\n        if (astarPath.length === 0)\r\n            return null;\r\n        // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n        astarPath.unshift(startPoly);\r\n        // We have a path, so now time for the funnel algorithm\r\n        const channel = new Channel();\r\n        channel.push(startVector);\r\n        for (let i = 0; i < astarPath.length - 1; i++) {\r\n            const navPolygon = astarPath[i];\r\n            const nextNavPolygon = astarPath[i + 1];\r\n            // Find the portal\r\n            let portal = null;\r\n            for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n                if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n                    portal = navPolygon.portals[i];\r\n                }\r\n            }\r\n            if (!portal)\r\n                throw new Error(\"Path was supposed to be found, but portal is missing!\");\r\n            // Push the portal vertices into the channel\r\n            channel.push(portal.start, portal.end);\r\n        }\r\n        channel.push(endVector);\r\n        // Pull a string along the channel to run the funnel\r\n        channel.stringPull();\r\n        // Clone path, excluding duplicates\r\n        let lastPoint = null;\r\n        const phaserPath = [];\r\n        for (const p of channel.path) {\r\n            const newPoint = p.clone();\r\n            if (!lastPoint || !newPoint.equals(lastPoint))\r\n                phaserPath.push(newPoint);\r\n            lastPoint = newPoint;\r\n        }\r\n        return phaserPath;\r\n    }\r\n    calculateNeighbors() {\r\n        // Fill out the neighbor information for each navpoly\r\n        for (let i = 0; i < this.navPolygons.length; i++) {\r\n            const navPoly = this.navPolygons[i];\r\n            for (let j = i + 1; j < this.navPolygons.length; j++) {\r\n                const otherNavPoly = this.navPolygons[j];\r\n                // Check if the other navpoly is within range to touch\r\n                const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n                if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius)\r\n                    continue;\r\n                // The are in range, so check each edge pairing\r\n                for (const edge of navPoly.edges) {\r\n                    for (const otherEdge of otherNavPoly.edges) {\r\n                        // If edges aren't collinear, not an option for connecting navpolys\r\n                        if (!areCollinear(edge, otherEdge))\r\n                            continue;\r\n                        // If they are collinear, check if they overlap\r\n                        const overlap = this.getSegmentOverlap(edge, otherEdge);\r\n                        if (!overlap)\r\n                            continue;\r\n                        // Connections are symmetric!\r\n                        navPoly.neighbors.push(otherNavPoly);\r\n                        otherNavPoly.neighbors.push(navPoly);\r\n                        // Calculate the portal between the two polygons - this needs to be in\r\n                        // counter-clockwise order, relative to each polygon\r\n                        const [p1, p2] = overlap;\r\n                        let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n                        let a1 = navPoly.centroid.angle(overlap[0]);\r\n                        let a2 = navPoly.centroid.angle(overlap[1]);\r\n                        let d1 = angleDifference(edgeStartAngle, a1);\r\n                        let d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            navPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n                        }\r\n                        else {\r\n                            navPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n                        edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n                        a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n                        a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n                        d1 = angleDifference(edgeStartAngle, a1);\r\n                        d2 = angleDifference(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            otherNavPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n                        }\r\n                        else {\r\n                            otherNavPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n                        // Two convex polygons shouldn't be connected more than once! (Unless\r\n                        // there are unnecessary vertices...)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Check two collinear line segments to see if they overlap by sorting the points.\r\n    // Algorithm source: http://stackoverflow.com/a/17152247\r\n    getSegmentOverlap(line1, line2) {\r\n        const points = [\r\n            { line: line1, point: line1.start },\r\n            { line: line1, point: line1.end },\r\n            { line: line2, point: line2.start },\r\n            { line: line2, point: line2.end },\r\n        ];\r\n        points.sort(function (a, b) {\r\n            if (a.point.x < b.point.x)\r\n                return -1;\r\n            else if (a.point.x > b.point.x)\r\n                return 1;\r\n            else {\r\n                if (a.point.y < b.point.y)\r\n                    return -1;\r\n                else if (a.point.y > b.point.y)\r\n                    return 1;\r\n                else\r\n                    return 0;\r\n            }\r\n        });\r\n        // If the first two points in the array come from the same line, no overlap\r\n        const noOverlap = points[0].line === points[1].line;\r\n        // If the two middle points in the array are the same coordinates, then there is a\r\n        // single point of overlap.\r\n        const singlePointOverlap = points[1].point.equals(points[2].point);\r\n        if (noOverlap || singlePointOverlap)\r\n            return null;\r\n        else\r\n            return [points[1].point, points[2].point];\r\n    }\r\n    /**\r\n     * Project a point onto a polygon in the shortest distance possible.\r\n     *\r\n     * @param {Phaser.Point} point The point to project\r\n     * @param {NavPoly} navPoly The navigation polygon to test against\r\n     * @returns {{point: Phaser.Point, distance: number}}\r\n     */\r\n    projectPointToPolygon(point, navPoly) {\r\n        let closestProjection = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        for (const edge of navPoly.edges) {\r\n            const projectedPoint = projectPointToEdge(point, edge);\r\n            const d = point.distance(projectedPoint);\r\n            if (closestProjection === null || d < closestDistance) {\r\n                closestDistance = d;\r\n                closestProjection = projectedPoint;\r\n            }\r\n        }\r\n        return { point: closestProjection, distance: closestDistance };\r\n    }\r\n}\r\n","import jsastar from \"javascript-astar\";\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph\r\n * @private\r\n */\r\nclass NavGraph {\r\n    nodes;\r\n    grid = [];\r\n    constructor(navPolygons) {\r\n        this.nodes = navPolygons;\r\n        this.init();\r\n    }\r\n    neighbors(navPolygon) {\r\n        return navPolygon.neighbors;\r\n    }\r\n    navHeuristic(navPolygon1, navPolygon2) {\r\n        return navPolygon1.centroidDistance(navPolygon2);\r\n    }\r\n    destroy() {\r\n        this.cleanDirty();\r\n        this.nodes = [];\r\n    }\r\n    init = jsastar.Graph.prototype.init.bind(this);\r\n    cleanDirty = jsastar.Graph.prototype.cleanDirty.bind(this);\r\n    markDirty = jsastar.Graph.prototype.markDirty.bind(this);\r\n    toString = jsastar.Graph.prototype.toString.bind(this);\r\n}\r\nexport default NavGraph;\r\n","export class GridMap {\r\n    width;\r\n    height;\r\n    tileWidth;\r\n    tileHeight;\r\n    map;\r\n    isWalkableTest;\r\n    constructor(map, isWalkable, tileWidth, tileHeight) {\r\n        this.map = map;\r\n        this.isWalkableTest = isWalkable;\r\n        this.height = map.length;\r\n        this.width = map[0].length;\r\n        this.tileWidth = tileWidth;\r\n        this.tileHeight = tileHeight;\r\n    }\r\n    forEach(fn) {\r\n        this.map.forEach((row, y) => {\r\n            row.forEach((col, x) => {\r\n                fn(x, y, this.map[y][x]);\r\n            });\r\n        });\r\n    }\r\n    isInGrid(x, y) {\r\n        return x >= 0 && x < this.width && y >= 0 && y < this.height;\r\n    }\r\n    isWalkable(x, y) {\r\n        return this.isInGrid(x, y) && this.isWalkableTest(this.map[y][x], x, y);\r\n    }\r\n    isBlocked(x, y) {\r\n        return this.isInGrid(x, y) && !this.isWalkableTest(this.map[y][x], x, y);\r\n    }\r\n    isBlockedAtWorld(worldX, worldY) {\r\n        return this.isBlocked(this.getGridX(worldX), this.getGridY(worldY));\r\n    }\r\n    getGridX(worldX) {\r\n        return Math.floor(worldX / this.tileWidth);\r\n    }\r\n    getGridY(worldY) {\r\n        return Math.floor(worldY / this.tileHeight);\r\n    }\r\n    getGridXY(worldX, worldY) {\r\n        return { x: this.getGridX(worldX), y: this.getGridY(worldY) };\r\n    }\r\n    getWorldX(gridX) {\r\n        return gridX * this.tileWidth;\r\n    }\r\n    getWorldY(gridY) {\r\n        return gridY * this.tileHeight;\r\n    }\r\n    getWorldXY(gridX, gridY) {\r\n        return { x: this.getWorldX(gridX), y: this.getWorldY(gridY) };\r\n    }\r\n}\r\n","/**\r\n * Internal helper class to manage a queue of points when parsing a square map.\r\n */\r\nexport class PointQueue {\r\n    data = [];\r\n    add(point) {\r\n        this.data.push(point);\r\n    }\r\n    shift() {\r\n        return this.data.shift();\r\n    }\r\n    isEmpty() {\r\n        return this.data.length === 0;\r\n    }\r\n    containsPoint(point) {\r\n        return this.data.find((p) => p.x === point.x && p.y === point.y) !== undefined ? true : false;\r\n    }\r\n    containsAllPoints(points) {\r\n        return points.every((p) => this.containsPoint(p));\r\n    }\r\n    getIndexOfPoint(point) {\r\n        return this.data.findIndex((p) => p.x == point.x && p.y == point.y);\r\n    }\r\n    removePoint(point) {\r\n        const index = this.getIndexOfPoint(point);\r\n        if (index !== -1)\r\n            this.data.splice(index, 1);\r\n    }\r\n    removePoints(points) {\r\n        points.forEach((p) => this.removePoint(p));\r\n    }\r\n}\r\n","/**\r\n * Class for managing hulls created by combining square tiles.\r\n */\r\nexport class RectangleHull {\r\n    x;\r\n    y;\r\n    width;\r\n    height;\r\n    constructor(x, y, width, height) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    setPosition(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    setSize(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    set(left, top, width, height) {\r\n        this.setPosition(left, top);\r\n        this.setSize(width, height);\r\n    }\r\n    get left() {\r\n        return this.x;\r\n    }\r\n    set left(val) {\r\n        this.x = val;\r\n    }\r\n    get top() {\r\n        return this.y;\r\n    }\r\n    set top(val) {\r\n        this.y = val;\r\n    }\r\n    // TODO: make consistent. Either left/right should both resize or they should both just reposition\r\n    get right() {\r\n        return this.x + this.width;\r\n    }\r\n    set right(val) {\r\n        this.width = val - this.x;\r\n    }\r\n    get bottom() {\r\n        return this.y + this.height;\r\n    }\r\n    set bottom(val) {\r\n        this.height = val - this.top;\r\n    }\r\n    get center() {\r\n        return { x: (this.x + this.right) / 2, y: (this.y + this.bottom) / 2 };\r\n    }\r\n    doesOverlap(otherHull) {\r\n        return !(this.right < otherHull.x ||\r\n            this.x > otherHull.right ||\r\n            this.y > otherHull.bottom ||\r\n            this.bottom < otherHull.y);\r\n    }\r\n    /**\r\n     * Attempt to merge another hull into this one. If they share an edge, `this` will be extended to\r\n     * contain `otherHull`.\r\n     * @param otherHull\r\n     */\r\n    attemptMergeIn(otherHull) {\r\n        const horizontalMatch = this.x === otherHull.x && this.width === otherHull.width;\r\n        const verticalMatch = this.y === otherHull.y && this.height === otherHull.height;\r\n        if (horizontalMatch && this.top === otherHull.bottom) {\r\n            this.height += otherHull.height;\r\n            this.y = otherHull.y;\r\n            return true;\r\n        }\r\n        if (horizontalMatch && this.bottom === otherHull.top) {\r\n            this.bottom = otherHull.bottom;\r\n            return true;\r\n        }\r\n        if (verticalMatch && this.left === otherHull.right) {\r\n            this.width += otherHull.width;\r\n            this.x = otherHull.x;\r\n            return true;\r\n        }\r\n        if (verticalMatch && this.right === otherHull.left) {\r\n            this.right = otherHull.right;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    toPoints() {\r\n        const { left, right, top, bottom } = this;\r\n        return [\r\n            { x: left, y: top },\r\n            { x: right, y: top },\r\n            { x: right, y: bottom },\r\n            { x: left, y: bottom },\r\n        ];\r\n    }\r\n}\r\n","import { isTruthy } from \"../utils\";\r\nimport { GridMap } from \"./grid-map\";\r\nimport { PointQueue } from \"./point-queue\";\r\nimport { RectangleHull } from \"./rectangle-hull\";\r\n/**\r\n * This parses a world that is a uniform grid into convex polygons (specifically rectangles) that\r\n * can be used for building a navmesh. This is designed mainly for parsing tilemaps into polygons.\r\n * The functions takes a 2D array that indicates which tiles are walkable and which aren't. The\r\n * function returns PolyPoint[] that can be used to construct a NavMesh.\r\n *\r\n * Notes:\r\n * - This algorithm traverses the walkable tiles in a depth-first search, combining neighbors into\r\n *   rectangular polygons. This may not produce the best navmesh, but it doesn't require any manual\r\n *   work!\r\n * - This assumes the world is a uniform grid. It should work for any tile size, provided that all\r\n *   tiles are the same width and height.\r\n *\r\n * @param map 2D array of any type.\r\n * @param tileWidth The width of each tile in the grid.\r\n * @param tileHeight The height of each tile in the grid.\r\n * @param isWalkable Function that is used to test if a specific location in the map is walkable.\r\n * Defaults to assuming \"truthy\" means walkable.\r\n * @param [shrinkAmount=0] Amount to \"shrink\" the mesh away from the tiles. This adds more polygons\r\n * to the generated mesh, but can be helpful for preventing agents from getting caught on edges.\r\n * This supports values between 0 and tileWidth/tileHeight (whichever dimension is smaller).\r\n */\r\nexport default function buildPolysFromGridMap(map, tileWidth = 1, tileHeight = 1, isWalkable = isTruthy, shrinkAmount = 0) {\r\n    const gridMap = new GridMap(map, isWalkable, tileWidth, tileHeight);\r\n    if (shrinkAmount >= tileWidth || shrinkAmount >= tileHeight) {\r\n        throw new Error(`navmesh: Unsupported shrink amount ${shrinkAmount}. Must be less than tile width and height.`);\r\n    }\r\n    let hulls = buildInitialHulls(gridMap);\r\n    if (shrinkAmount > 0) {\r\n        hulls = shrinkHulls(hulls, gridMap, shrinkAmount);\r\n    }\r\n    return hulls.map((hull) => hull.toPoints());\r\n}\r\n/**\r\n * Build up rectangular hulls from the walkable areas of a GridMap. This starts with a walkable tile\r\n * and attempts to \"grow\" each of its edges to engulf its neighbors. This process repeats until the\r\n * current hull can't engulf any neighbors.\r\n * @param gridMap\r\n */\r\nfunction buildInitialHulls(gridMap) {\r\n    const walkableQueue = new PointQueue();\r\n    const { tileWidth, tileHeight } = gridMap;\r\n    const hulls = [];\r\n    let currentHull;\r\n    gridMap.forEach((x, y) => {\r\n        if (gridMap.isWalkable(x, y))\r\n            walkableQueue.add({ x, y });\r\n    });\r\n    const getExtensionPoints = (hull, dir) => {\r\n        const { top, left, right, bottom } = hull;\r\n        let points = [];\r\n        if (dir === \"top\") {\r\n            for (let x = left; x <= right - 1; x++)\r\n                points.push({ x, y: top });\r\n        }\r\n        else if (dir === \"bottom\") {\r\n            for (let x = left; x <= right - 1; x++)\r\n                points.push({ x, y: bottom });\r\n        }\r\n        else if (dir === \"left\") {\r\n            for (let y = top; y <= bottom - 1; y++)\r\n                points.push({ x: left, y });\r\n        }\r\n        else if (dir === \"right\") {\r\n            for (let y = top; y <= bottom - 1; y++)\r\n                points.push({ x: right, y });\r\n        }\r\n        else {\r\n            throw new Error(`Invalid dir \"${dir}\" for extend`);\r\n        }\r\n        return points;\r\n    };\r\n    const extendHullInDirection = (hull, dir) => {\r\n        if (dir === \"top\")\r\n            hull.y -= 1;\r\n        else if (dir === \"bottom\")\r\n            hull.bottom += 1;\r\n        else if (dir === \"left\")\r\n            hull.x -= 1;\r\n        else if (dir === \"right\")\r\n            hull.right += 1;\r\n        else\r\n            throw new Error(`Invalid dir \"${dir}\" for extend`);\r\n    };\r\n    const attemptExtension = (hull, dir) => {\r\n        const neighborPoints = getExtensionPoints(hull, dir);\r\n        const canExtend = walkableQueue.containsAllPoints(neighborPoints);\r\n        if (canExtend) {\r\n            extendHullInDirection(hull, dir);\r\n            walkableQueue.removePoints(neighborPoints);\r\n        }\r\n        return canExtend;\r\n    };\r\n    while (!walkableQueue.isEmpty()) {\r\n        // Find next colliding tile to start the algorithm.\r\n        const tile = walkableQueue.shift();\r\n        if (tile === undefined)\r\n            break;\r\n        // Use tile dimensions (i.e. 1 tile wide, 1 tile tall) to simplify the checks.\r\n        currentHull = new RectangleHull(tile.x, tile.y, 1, 1);\r\n        // Check edges of bounding box to see if they can be extended.\r\n        let needsExtensionCheck = true;\r\n        while (needsExtensionCheck) {\r\n            const extendedTop = attemptExtension(currentHull, \"top\");\r\n            const extendedRight = attemptExtension(currentHull, \"right\");\r\n            const extendedLeft = attemptExtension(currentHull, \"left\");\r\n            const extendedBottom = attemptExtension(currentHull, \"bottom\");\r\n            needsExtensionCheck = extendedTop || extendedBottom || extendedLeft || extendedRight;\r\n        }\r\n        // Scale the hull up from grid dimensions to real world dimensions.\r\n        currentHull.setPosition(currentHull.x * tileWidth, currentHull.y * tileHeight);\r\n        currentHull.setSize(currentHull.width * tileWidth, currentHull.height * tileHeight);\r\n        hulls.push(currentHull);\r\n    }\r\n    return hulls;\r\n}\r\n// TODO: check larger than tile size. Assumes shrink <= 1 tile.\r\nfunction shrinkHull(hull, gridMap, shrinkAmount, tileWidth, tileHeight) {\r\n    const s = shrinkAmount;\r\n    const halfWidth = tileWidth / 2;\r\n    const halfHeight = tileHeight / 2;\r\n    const { left, top, right, bottom } = hull;\r\n    const info = {\r\n        left: false,\r\n        right: false,\r\n        top: false,\r\n        bottom: false,\r\n        topLeft: gridMap.isBlockedAtWorld(left - s, top - s),\r\n        topRight: gridMap.isBlockedAtWorld(right + s, top - s),\r\n        bottomLeft: gridMap.isBlockedAtWorld(left - s, bottom + s),\r\n        bottomRight: gridMap.isBlockedAtWorld(right + s, bottom + s),\r\n    };\r\n    for (let y = top + halfHeight; y < bottom; y += halfHeight) {\r\n        if (gridMap.isBlockedAtWorld(left - s, y)) {\r\n            info.left = true;\r\n            break;\r\n        }\r\n    }\r\n    for (let y = top + halfHeight; y < bottom; y += halfHeight) {\r\n        if (gridMap.isBlockedAtWorld(right + s, y)) {\r\n            info.right = true;\r\n            break;\r\n        }\r\n    }\r\n    for (let x = left + halfWidth; x < right; x += halfWidth) {\r\n        if (gridMap.isBlockedAtWorld(x, top - shrinkAmount)) {\r\n            info.top = true;\r\n            break;\r\n        }\r\n    }\r\n    for (let x = left + halfWidth; x < right; x += halfWidth) {\r\n        if (gridMap.isBlockedAtWorld(x, bottom + shrinkAmount)) {\r\n            info.bottom = true;\r\n            break;\r\n        }\r\n    }\r\n    const shrink = {\r\n        left: info.left,\r\n        right: info.right,\r\n        top: info.top,\r\n        bottom: info.bottom,\r\n    };\r\n    if (info.topLeft && !info.left && !info.top) {\r\n        if (hull.width > hull.height)\r\n            shrink.left = true;\r\n        else\r\n            shrink.top = true;\r\n    }\r\n    if (info.topRight && !info.right && !info.top) {\r\n        if (hull.width > hull.height)\r\n            shrink.right = true;\r\n        else\r\n            shrink.top = true;\r\n    }\r\n    if (info.bottomLeft && !info.bottom && !info.left) {\r\n        if (hull.width > hull.height)\r\n            shrink.left = true;\r\n        else\r\n            shrink.bottom = true;\r\n    }\r\n    if (info.bottomRight && !info.bottom && !info.right) {\r\n        if (hull.width > hull.height)\r\n            shrink.right = true;\r\n        else\r\n            shrink.bottom = true;\r\n    }\r\n    if (shrink.left) {\r\n        hull.x += shrinkAmount;\r\n        hull.width -= shrinkAmount;\r\n    }\r\n    if (shrink.top) {\r\n        hull.y += shrinkAmount;\r\n        hull.height -= shrinkAmount;\r\n    }\r\n    if (shrink.right) {\r\n        hull.width -= shrinkAmount;\r\n    }\r\n    if (shrink.bottom) {\r\n        hull.height -= shrinkAmount;\r\n    }\r\n    return shrink;\r\n}\r\nfunction shrinkHulls(hulls, gridMap, shrinkAmount) {\r\n    const { tileHeight, tileWidth } = gridMap;\r\n    const newHulls = [];\r\n    const finalHulls = [];\r\n    hulls.forEach((hull, hullIndex) => {\r\n        const th = tileHeight;\r\n        const tw = tileWidth;\r\n        const tLeft = gridMap.getGridX(hull.x);\r\n        const tTop = gridMap.getGridY(hull.y);\r\n        const tBottom = gridMap.getGridY(hull.bottom);\r\n        const tRight = gridMap.getGridX(hull.right);\r\n        const shrink = shrinkHull(hull, gridMap, shrinkAmount, tileWidth, tileHeight);\r\n        if (hull.left >= hull.right || hull.top >= hull.bottom)\r\n            return;\r\n        finalHulls.push(hull);\r\n        const newVerticalHulls = [];\r\n        const newHorizontalHulls = [];\r\n        const addHull = (x, y, w, h) => {\r\n            const hull = new RectangleHull(x, y, w, h);\r\n            if (w > h)\r\n                newHorizontalHulls.push(hull);\r\n            else\r\n                newVerticalHulls.push(hull);\r\n        };\r\n        if (shrink.left) {\r\n            const x = hull.left - shrinkAmount;\r\n            let startY = tTop;\r\n            let endY = startY - 1;\r\n            for (let y = tTop; y < tBottom; y++) {\r\n                if (gridMap.isBlocked(tLeft - 1, y)) {\r\n                    if (startY <= endY) {\r\n                        addHull(x, startY * th, shrinkAmount, (endY - startY + 1) * th);\r\n                    }\r\n                    startY = y + 1;\r\n                }\r\n                else {\r\n                    endY = y;\r\n                }\r\n            }\r\n            if (startY <= endY) {\r\n                addHull(x, startY * th, shrinkAmount, (endY - startY + 1) * th);\r\n            }\r\n        }\r\n        if (shrink.right) {\r\n            const x = hull.right;\r\n            let startY = tTop;\r\n            let endY = startY - 1;\r\n            for (let y = tTop; y < tBottom; y++) {\r\n                if (gridMap.isBlocked(tRight, y)) {\r\n                    if (startY <= endY) {\r\n                        addHull(x, startY * th, shrinkAmount, (endY - startY + 1) * th);\r\n                    }\r\n                    startY = y + 1;\r\n                }\r\n                else {\r\n                    endY = y;\r\n                }\r\n            }\r\n            if (startY <= endY) {\r\n                addHull(x, startY * th, shrinkAmount, (endY - startY + 1) * th);\r\n            }\r\n        }\r\n        if (shrink.top) {\r\n            const y = hull.top - shrinkAmount;\r\n            let startX = tLeft;\r\n            let endX = startX - 1;\r\n            for (let x = tLeft; x < tRight; x++) {\r\n                if (gridMap.isBlocked(x, tTop - 1)) {\r\n                    if (startX <= endX) {\r\n                        addHull(startX * tw, y, (endX - startX + 1) * th, shrinkAmount);\r\n                    }\r\n                    startX = x + 1;\r\n                }\r\n                else {\r\n                    endX = x;\r\n                }\r\n            }\r\n            if (startX <= endX) {\r\n                addHull(startX * tw, y, (endX - startX + 1) * th, shrinkAmount);\r\n            }\r\n        }\r\n        if (shrink.bottom) {\r\n            const y = hull.bottom;\r\n            let startX = tLeft;\r\n            let endX = startX - 1;\r\n            for (let x = tLeft; x < tRight; x++) {\r\n                if (gridMap.isBlocked(x, tBottom)) {\r\n                    if (startX <= endX) {\r\n                        addHull(startX * tw, y, (endX - startX + 1) * th, shrinkAmount);\r\n                    }\r\n                    startX = x + 1;\r\n                }\r\n                else {\r\n                    endX = x;\r\n                }\r\n            }\r\n            if (startX <= endX) {\r\n                addHull(startX * tw, y, (endX - startX + 1) * th, shrinkAmount);\r\n            }\r\n        }\r\n        // Shrunk at corners when the new hulls overlap.\r\n        newHorizontalHulls.forEach((hh) => {\r\n            newVerticalHulls.forEach((vh) => {\r\n                if (hh.doesOverlap(vh)) {\r\n                    const isBottomSide = hh.y > vh.y;\r\n                    if (isBottomSide)\r\n                        vh.height -= shrinkAmount;\r\n                    else\r\n                        vh.top += shrinkAmount;\r\n                }\r\n            });\r\n        });\r\n        [...newHorizontalHulls, ...newVerticalHulls].forEach((hull) => {\r\n            shrinkHull(hull, gridMap, shrinkAmount, tileWidth, tileHeight);\r\n            if (hull.left >= hull.right || hull.top >= hull.bottom)\r\n                return;\r\n            newHulls.push(hull);\r\n        });\r\n    });\r\n    // Attempt to merge new hulls into existing hulls if possible.\r\n    for (let i = 0; i < newHulls.length; i++) {\r\n        let wasMerged = false;\r\n        // Attempt to merge into the main (shrunken) hulls first.\r\n        for (const mainHull of hulls) {\r\n            wasMerged = mainHull.attemptMergeIn(newHulls[i]);\r\n            if (wasMerged)\r\n                break;\r\n        }\r\n        if (wasMerged)\r\n            continue;\r\n        // Then check to see if we can merge into a later hull in newHulls.\r\n        for (let j = i + 1; j < newHulls.length; j++) {\r\n            wasMerged = newHulls[j].attemptMergeIn(newHulls[i]);\r\n            if (wasMerged)\r\n                break;\r\n        }\r\n        if (!wasMerged)\r\n            finalHulls.push(newHulls[i]);\r\n    }\r\n    return finalHulls;\r\n}\r\n","/**\r\n * `navmesh` is the core logic package. It is game-engine agnostic, usable outside of Phaser.\r\n * @packageDocumentation\r\n * @module navmesh\r\n */\r\nimport NavMesh from \"./navmesh\";\r\nexport { NavMesh };\r\nexport * from \"./common-types\";\r\nexport * from \"./map-parsers\";\r\nexport default NavMesh;\r\n"],"sourceRoot":""}